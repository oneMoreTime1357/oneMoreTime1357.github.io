<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 解锁 Vue多页面应用 · MissYang</title><meta name="description" content="解锁 Vue多页面应用 - Sunny Yang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yikeshu.info/atom.xml" title="MissYang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon-logo.png" alt="logo"><span>Sunny Yang</span></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/oneMoreTime1357" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/459674901bd7" target="_blank" class="nav-list-link">JANSHU</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">解锁 Vue多页面应用</h1><div class="post-info">Jul 14, 2018</div><div class="post-content"><p>大部分使用Vue是构建单页面应用，但有时候我们也需要多页面应用，比如手机端的H5页面，可能这块需要一个H5页，另一块需要一个H5活动页，彼此相互独立，根本就没有什么关联，这时候还使用单页面应用增加了页面加载的速度，而且打包了一大堆和本页面无关的代码，增加了页面响应时间。</p>
<a id="more"></a>
<p><strong>准备工作：</strong><br>使用vue-cli构建工具，添加项目。<br>最近vue-cli发布了最新版本v3.0.0，如果使用最新版本的脚手架，就不会暴露出webpack的一些配置文件，没办法自定义了，所以本次配置多页面构建还是使用的Vue CLI 2</p>
<pre><code>npm install -g vue-cli

vue init webpack vue-mutile-page
</code></pre><p>使用此模板创建的vue项目，集成的是webpack3，现在webpack已经升级到4了，暂时先按照模板来使用webpack3吧，先把架子搭好，后期想升级到最新也是可以的。</p>
<h4 id="单页面应用打包之后dist目录"><a href="#单页面应用打包之后dist目录" class="headerlink" title="单页面应用打包之后dist目录"></a>单页面应用打包之后dist目录</h4><p>直接使用模板创建的项目是单页面应用的，配置文件都是写好的，所以我们可以直接执行命令打包</p>
<pre><code>npm run dev
</code></pre><p>打包完成之后会生成dist目录，只生成一个入口文件index.html，然后static中有打包好的js和css文件.</p>
<pre><code>├── dist
|    ├── index.html
|    └── static
|       ├── css
|       └── js
</code></pre><h2 id="多页面应用"><a href="#多页面应用" class="headerlink" title="多页面应用"></a>多页面应用</h2><p>上面是常见的单页面应用打包之后的目录，那多页面打包之后应该是什么样的呢？</p>
<p>多页面应用就意味着有多个页面，单页面打包之后只生成一个html文件，这个文件就是项目的入口文件，多页面也就是说每个页面都应该有一个自己的html文件，页面和页面之间是相互独立的，那在打包之后dist目录应该生成每个页面的html文件。比如我有page1和page2，dist目录中应该生成下面的结构，各自的页面名称对应各自的html文件。那要怎么做到呢，请看下文分解。</p>
<pre><code>├── dist
|    ├── page1.html
|    ├── page1.html
|    └── static
|       ├── css
|       │   
|       └── js
|
</code></pre><h3 id="改写项目目录"><a href="#改写项目目录" class="headerlink" title="改写项目目录"></a>改写项目目录</h3><p>想要搭建多页面的应用，首先要改写刚刚生成的项目目录结构。</p>
<p>下面是我修改之后的目录结构</p>
<pre><code>.
├── .babelrc
├── .editorconfig
├── .eslintignore
├── .eslintrc.js
├── .gitignore
├── .postcssrc.js
├── README.md
├── build
│   ├── build.js
│   ├── check-versions.js
│   ├── utils.js
│   ├── vue-loader.conf.js
│   ├── webpack.base.conf.js
│   ├── webpack.dev.conf.js
│   └── webpack.prod.conf.js
├── config
│   ├── dev.env.js
│   ├── index.js
│   ├── prod.env.js
│   └── test.env.js
├── package.json
├── src
│   ├── assets
│   │   └── logo.png
│   ├── components
│   │   └── HelloWorld.vue
│   └── pages
│       ├── page1
│       │   ├── App.vue
│       │   ├── index.ejs
│       │   └── index.js
│       └── page2
│           ├── App.vue
│           ├── index.ejs
│           └── index.js
└── static
</code></pre><p>修改的点</p>
<ol>
<li>在src文件下创建pages目录，这是我们创建多页面放置的地方</li>
<li>pages目录下是根据页面名称命名的文件夹，文件夹下包含三个文件，后缀为：<code>.vue .ejs .js</code>这三个文件，后缀为.vue 和 .js 的文件分别对应项目创建时的App.vue 和main.js文件，现在都放到页面文件中，.ejs文件对应的是根目录下的index.html文件，也就是项目的入口文件。</li>
<li>把src下的App.vue 和main.js删除，根目录下的index.html也删除，因为这些都已经移到页面中了。</li>
</ol>
<p>项目目录整理好之后，那接下来我们就可以写配置文件了，配置文件的修改都在build目录下。更改的目录主要有下面这几个</p>
<pre><code>├── build
│   ├── utils.js
│   ├── webpack.base.conf.js
│   ├── webpack.dev.conf.js
│   └── webpack.prod.conf.js
</code></pre><h3 id="修改utils-js文件"><a href="#修改utils-js文件" class="headerlink" title="修改utils.js文件"></a>修改utils.js文件</h3><p>在utils文件中增加两个函数，一个是获取多页面路径作为entry文件的入口，另一个是生成页面多页面plugin的配置，废话不多说，上代码。</p>
<p>首先需要安装一个node模块<a href="https://www.npmjs.com/package/glob" target="_blank" rel="noopener">glob</a>，glob可以读取相应后缀名的文件，便于检索出需要的文件。</p>
<pre><code>npm install --save-dev glob
</code></pre><p>在utils.js中添加如下代码</p>
<pre><code>const glob = require(&#39;glob&#39;)
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)
const merge = require(&#39;webpack-merge&#39;)

const PAGE_PATH = path.resolve(__dirname, &#39;../src/pages&#39;)

// 多页面入口文件配置
exports.entries = function () {
//  读取pages下的 页面名称文件下的后缀为js的文件
  var entryFiles = glob.sync(PAGE_PATH + &#39;/*/*.js&#39;)
  var map = {}
  entryFiles.forEach((filePath) =&gt; {
    // 因为后缀为js的文件名在index，而我们想获取的是
    var pathArry = filePath.split(&#39;/&#39;)
    var filename = pathArry[pathArry.length - 2]
    map[filename] = filePath
  })
  // 整理成文件名为Key，路径为value的Object对象
  return map
}

// 多页面输出配置
exports.htmlPlugin = function () {
  let entryHtml = glob.sync(PAGE_PATH + &#39;/*/*.ejs&#39;)
  let arr = []
  entryHtml.forEach((filePath) =&gt; {
    let pathArry = filePath.split(&#39;/&#39;)
    // 获取页面名
    let filename = pathArry[pathArry.length - 2]

    let conf = {
      template: filePath,
      filename: filename + &#39;.html&#39;,
      chunks: [&#39;manifest&#39;, &#39;vendor&#39;, filename],
      inject: true
    }

    if (process.env.NODE_ENV === &#39;production&#39;) {
      conf = merge(conf, {
        minify: {
          removeComments: true,
          collapseWhitespace: true,
          removeAttributeQuotos: true
        },
        chunksSortMode: &#39;dependency&#39;
      })
    }
    arr.push(new HtmlWebpackPlugin(conf))
  })
  return arr
}
</code></pre><h3 id="修改webpack-base-conf-js"><a href="#修改webpack-base-conf-js" class="headerlink" title="修改webpack.base.conf.js"></a>修改webpack.base.conf.js</h3><p>代码如下，修改的部分只有入口文件的配置</p>
<pre><code>const path = require(&#39;path&#39;)
const utils = require(&#39;./utils&#39;)
const config = require(&#39;../config&#39;)
const vueLoaderConfig = require(&#39;./vue-loader.conf&#39;)

function resolve (dir) {
  return path.join(__dirname, &#39;..&#39;, dir)
}

const createLintingRule = () =&gt; ({
  test: /\.(js|vue)$/,
  loader: &#39;eslint-loader&#39;,
  enforce: &#39;pre&#39;,
  include: [resolve(&#39;src&#39;), resolve(&#39;test&#39;)],
  options: {
    formatter: require(&#39;eslint-friendly-formatter&#39;),
    emitWarning: !config.dev.showEslintErrorsInOverlay
  }
})

module.exports = {
  context: path.resolve(__dirname, &#39;../&#39;),
  // 修改的部分=====开始
  entry: utils.entries(),
  // 修改的部分 === 结束
  output: {
    path: config.build.assetsRoot,
    filename: &#39;[name].js&#39;,
    publicPath: process.env.NODE_ENV === &#39;production&#39;
      ? config.build.assetsPublicPath
      : config.dev.assetsPublicPath
  },
  resolve: {
    extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;],
    alias: {
      &#39;vue$&#39;: &#39;vue/dist/vue.esm.js&#39;,
      &#39;@&#39;: resolve(&#39;src&#39;),
    }
  },
  module: {
    rules: [
      ...(config.dev.useEslint ? [createLintingRule()] : []),
      {
        test: /\.vue$/,
        loader: &#39;vue-loader&#39;,
        options: vueLoaderConfig
      },
      {
        test: /\.js$/,
        loader: &#39;babel-loader&#39;,
        include: [resolve(&#39;src&#39;), resolve(&#39;test&#39;), resolve(&#39;node_modules/webpack-dev-server/client&#39;)]
      },
      {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: &#39;url-loader&#39;,
        options: {
          limit: 10000,
          name: utils.assetsPath(&#39;img/[name].[hash:7].[ext]&#39;)
        }
      },
      {
        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
        loader: &#39;url-loader&#39;,
        options: {
          limit: 10000,
          name: utils.assetsPath(&#39;media/[name].[hash:7].[ext]&#39;)
        }
      },
      {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        loader: &#39;url-loader&#39;,
        options: {
          limit: 10000,
          name: utils.assetsPath(&#39;fonts/[name].[hash:7].[ext]&#39;)
        }
      }
    ]
  },
  node: {
    // prevent webpack from injecting useless setImmediate polyfill because Vue
    // source contains it (although only uses it if it&#39;s native).
    setImmediate: false,
    // prevent webpack from injecting mocks to Node native modules
    // that does not make sense for the client
    dgram: &#39;empty&#39;,
    fs: &#39;empty&#39;,
    net: &#39;empty&#39;,
    tls: &#39;empty&#39;,
    child_process: &#39;empty&#39;
  }
}
</code></pre><h3 id="webpack-dev-conf-js文件"><a href="#webpack-dev-conf-js文件" class="headerlink" title="webpack.dev.conf.js文件"></a>webpack.dev.conf.js文件</h3><p>完整代码比较多，只贴出了关键代码</p>
<pre><code>  plugins: [
    new webpack.DefinePlugin({
      &#39;process.env&#39;: require(&#39;../config/dev.env&#39;)
    }),
    new webpack.HotModuleReplacementPlugin(),
    new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.
    new webpack.NoEmitOnErrorsPlugin(),
    // https://github.com/ampedandwired/html-webpack-plugin

    //-------- 注掉 配置中的 HtmlWebpackPlugin 这个插件---------------

   // new HtmlWebpackPlugin({
    //  filename: &#39;index.html&#39;,
    //  template: &#39;index.html&#39;,
    //  inject: true
   // }),

   // ------------------------------------------------------------

    // copy custom static assets
    new CopyWebpackPlugin([
      {
        from: path.resolve(__dirname, &#39;../static&#39;),
        to: config.dev.assetsSubDirectory,
        ignore: [&#39;.*&#39;]
      }
    ])

    // 添加----------utils中我们写的另一个函数utils.htmlPlugin-----------
  ].concat(utils.htmlPlugin())
  // ---------------------------------------
</code></pre><h3 id="webpack-prod-conf-js文件"><a href="#webpack-prod-conf-js文件" class="headerlink" title="webpack.prod.conf.js文件"></a>webpack.prod.conf.js文件</h3><p>生产环境的配置和开发环境一样，先注掉配置文件中的webpack插件HtmlWebpackPlugin的那段代码，然后在将utils中我们之前写的htmlplugin函数，生成的数组添加到plugin上。操作和上面webpack.dev.conf.js文件相同。</p>
<hr>
<p>好了一切配置完成，现在就可以实验一下了，执行</p>
<pre><code>npm run build
</code></pre><p>如果没什么问题的话就可以看到dist目录中生成，在文章开始我们设想的打包之后的页面结构。</p>
<p>GitHub项目地址：<a href="https://github.com/oneMoreTime1357/Vue-multiple-page" target="_blank" rel="noopener">Vue-multiple-page</a></p>
<p><strong>参考资料</strong>：</p>
<p>官网Entry Points介绍<br><a href="https://webpack.js.org/concepts/entry-points/#src/components/Sidebar/Sidebar.jsx" target="_blank" rel="noopener">https://webpack.js.org/concepts/entry-points/#src/components/Sidebar/Sidebar.jsx</a></p>
<p>HtmlWebpackPlugin<br><a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">https://github.com/jantimon/html-webpack-plugin</a></p>
<p>Vue多页面应用 blog<br><a href="https://segmentfault.com/a/1190000011265006" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011265006</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/08/05/understand-promise/" class="prev">PREV</a><a href="/2018/06/10/Facebook、Twitter分享/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'http-yikeshu-info';
var disqus_identifier = '2018/07/14/解锁Vue-multiple-application/';
var disqus_title = '解锁 Vue多页面应用';
var disqus_url = 'http://yikeshu.info/2018/07/14/解锁Vue-multiple-application/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//http-yikeshu-info.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2018 <a href="http://yikeshu.info">Sunny Yang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/oneMoreTime1357/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>