<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Promise.all 处理error · MissYang</title><meta name="description" content="Promise.all 处理error - Sunny Yang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yikeshu.info/atom.xml" title="MissYang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon-logo.png" alt="logo"><span>Sunny Yang</span></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/oneMoreTime1357" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/459674901bd7" target="_blank" class="nav-list-link">JANSHU</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Promise.all 处理error</h1><div class="post-info">Oct 17, 2018</div><div class="post-content"><p><code>Promise.all()</code>接受一个由promise任务组成的数组，可以同时处理多个promise任务，当所有的任务都执行完成时，<code>Promise.all()</code>返回resolve，但当有一个失败(reject)，则返回失败的信息，即使其他promise执行成功，也会返回失败。可以用一句话来说<code>Promise.all()</code>，要么全有要么全无。<br><a id="more"></a><br>但话又说回来，有时候我们使用<code>Promise.all()</code>执行很多个网络请求，可能有一个请求出错，但我们并不希望其他的网络请求也返回reject，要错都错，这样显然是不合理的。</p>
<p>而我们需要的是即使有一两个接口请求失败，我们依然可以获取到成功的接口请求数据。</p>
<p>要想理解<code>Promise.all()</code>的机制请看上一篇《理解promise》中的Promise.All示例</p>
<p>那下面说说如何做才能做到promise.all中即使一个promise程序reject，promise.all依然能把其他数据正确返回。</p>
<p><strong>首先我们先创建一个resolve和reject的promise函数</strong></p>
<pre><code>const promiseResove = (promiseResolveSecond = function(n=0){
    return new Promise(function(resolve, reject){
        setTimeout(function() {
            resolve({
                resolveAfterSeconds: n
            })
        }, n * 100);
    })
})

const promiseReject = (promiseRejectSecond = function(n=0) {
    return new Promise(function(resolve, reject) {
        setTimeout(function () {
            reject({
                rejectAfterSeconds: n
            })
        }, n * 100)
    })
})
</code></pre><p><strong>使用上面的函数创建一个所有结果能正确返回的promise.all程序</strong></p>
<pre><code>var promiseArray = []
promiseArray.push(promiseResove(1))
promiseArray.push(promiseResove(3))
promiseArray.push(promiseResove(2))

var handlePromise = Promise.all(promiseArray)
handlePromise.then(function(values) {
    console.log(&#39;all promise are resolved&#39;, values)
}).catch(function(reason) {
    console.log(&#39;promise reject failed reason&#39;, reason)
})
</code></pre><ul>
<li>执行结果如下<br><img src="http://oybj22zxs.bkt.clouddn.com/19_49_30__08_01_2018.jpg" alt="promise all resolve"></li>
</ul>
<p><strong>然后在创建一个拥有reject函数返回的promise</strong></p>
<pre><code>var promiseArray = []
promiseArray.push(promiseResove(1))
promiseArray.push(promiseReject(3))
promiseArray.push(promiseResove(2))

var handlePromise = Promise.all(promiseArray)
handlePromise.then(function(values) {
    console.log(&#39;all promise are resolved&#39;, values)
}).catch(function(reason) {
    console.log(&#39;promise reject failed reason&#39;, reason)
})
</code></pre><ul>
<li>执行结果如下<br><img src="http://oybj22zxs.bkt.clouddn.com/19_53_41__08_01_2018.jpg" alt="promise all with reject"></li>
</ul>
<p>当<code>promise.all</code>中有一个promise执行失败返回reject时，promise.all直接返回执行失败的promise结果。</p>
<p>但我们还想看到其他两个resolve的结果，所以后面用一个trick方法，来解决这个问题。</p>
<p><strong>代码修改如下</strong></p>
<pre><code>var promiseArray = []
promiseArray.push(promiseResove(1))
promiseArray.push(promiseReject(3))
promiseArray.push(promiseResove(2))

// 将传入promise.all的数组进行遍历，如果catch住reject结果，
// 直接返回，这样就可以在最后结果中将所有结果都获取到
var handlePromise = Promise.all(promiseArray.map(function(promiseItem) {
    return promiseItem.catch(function(err) {
    return err
  })
}))
handlePromise.then(function(values) {
    console.log(&#39;all promise are resolved&#39;, values)
}).catch(function(reason) {
    console.log(&#39;promise reject failed reason&#39;, reason)
})
</code></pre><p>和之前唯一的不同就是在promise数组添加了一个回调函数，当数组中有接口reject时，catch住结果直接返回，这样失败的结果也可以当做成功处理，所以在promise.all中我们可以监听到所有结果的返回，然后在针对不同的返回值进行处理。</p>
<hr>
<p>参考链接<br><a href="https://stackoverflow.com/questions/30362733/handling-errors-in-promise-all" target="_blank" rel="noopener">https://stackoverflow.com/questions/30362733/handling-errors-in-promise-all</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/10/27/2018-10-27-document-ScrollingElement/" class="prev">PREV</a><a href="/2018/10/17/web-script-link-load/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'http-yikeshu-info';
var disqus_identifier = '2018/10/17/Promise-all-handle-error/';
var disqus_title = 'Promise.all 处理error';
var disqus_url = 'http://yikeshu.info/2018/10/17/Promise-all-handle-error/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//http-yikeshu-info.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2018 <a href="http://yikeshu.info">Sunny Yang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/oneMoreTime1357/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>