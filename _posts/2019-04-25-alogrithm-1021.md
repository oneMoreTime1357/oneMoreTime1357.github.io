---
layout: post
title: 算法 - “删除最外面的括号”
tags: 
  - 笔记
  - 算法
---

题目要求如下：

有效括号字符串为空 ("")、"(" + A + ")" 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。

如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。

给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。

对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。


```
示例 1：
输入："(()())(())"
输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。

示例 2：
输入："(()())(())(()(()))"
输出："()()()()(())"
解释：
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
删除每隔部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。

示例 3：
输入："()()"
输出：""
解释：
输入字符串为 "()()"，原语化分解得到 "()" + "()"，
删除每个部分中的最外层括号后得到 "" + "" = ""。
```

看完题目大概知道，这是在考察栈的问题，每一个括号都是成对出现的，需要将最外层的括号删除，保留里面的括号。

栈的特点就是先进后出。主要思路是关注右括号，如果右括号和左括号相等，说明是一个闭合的串，需要进行分解。如果未闭合就进行搜集起来

**JavaScript解决办法**

```js
var removeOuterParenthese = function (S) {
  let open = 0
  let combine = ''
  for (let c of S) {
    if (c == ')') {
      open --
    }
    if (open > 0) {
      combine += c
    }

    if (c === '(') {
      open ++
    }
  }
  return combine
}

console.log(removeOuterParenthese('(()())(())(()(()))'))
```

链接：

[Leetcode: 1021. 删除最外层的括号](https://leetcode-cn.com/problems/remove-outermost-parentheses/)
