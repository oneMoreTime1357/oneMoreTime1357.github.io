<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MissYang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yikeshu.info/"/>
  <updated>2018-04-14T14:45:16.000Z</updated>
  <id>http://yikeshu.info/</id>
  
  <author>
    <name>杨小丹</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>setTimeout &amp; setInterval</title>
    <link href="http://yikeshu.info/2018/04/14/setTimeout-setInterval/"/>
    <id>http://yikeshu.info/2018/04/14/setTimeout-setInterval/</id>
    <published>2018-04-14T10:46:15.744Z</published>
    <updated>2018-04-14T14:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。</p><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">    alert(&apos;hello word&apos;)</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure><p>上述代码设置了等待一秒之后弹出警告框。setTimeout有两个参数，第一个是传递一个函数，第二个是毫秒数，在等待设置的毫秒数之后执行函数的操作。<br><a id="more"></a><br>但是在经过该时间后不一定会执行指定的函数代码。<br>原因是：<strong>JavaScript是一个单线程解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个参数告诉JavaScript再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。</strong></p><p>在调用setTimeout之后，该方法会返回一个数值ID，表示超时调用。这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用<strong>clearTimeout</strong>方法并将ID作为参数传递给它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var timeoutId = setTimeout(function () &#123;</span><br><span class="line">    alert(&apos;hello world&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">clearTimeout(timeoutId)</span><br></pre></td></tr></table></figure></p><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h4><p>间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval(function () &#123;</span><br><span class="line">    alert(&apos;hello world&apos;)</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure></p><p>调用setInterval()方法同样会返回一个间歇调用ID，该ID可用于在将来某个时刻取消间歇调用。要取消间歇调用可以使用<strong>clearInterval()</strong>方法并传入相应的间歇调用ID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var max = 10</span><br><span class="line">var num = 0</span><br><span class="line">var intervalId = setInterval(function () &#123;</span><br><span class="line">    num++</span><br><span class="line">    if (num === max) &#123; // 当num达到最大值时取消间歇调用</span><br><span class="line">        clearInterval(intervalId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure></p><hr><h4 id="有趣的面试题"><a href="#有趣的面试题" class="headerlink" title="有趣的面试题"></a>有趣的面试题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;=5; i++) &#123;</span><br><span class="line">    setTimeout( function timer () &#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;, i * 1000);</span><br><span class="line">&#125;</span><br><span class="line">// 要求改动上述代码，使其依次输出1，2，3，4，5</span><br></pre></td></tr></table></figure><p>根据上面setTimeout的执行调用可知，JS是一个单线程解释器，一段时间只能执行一段代码，为了控制执行JS有自己的任务队列，这些任务会按照将它们添加到任务队列的顺序执行，而setTimeout中的时间参数是告诉JS多久之后将它添加到队列中。所以上面的setTimeout中要执行的函数，要等到for循环执行完成之后，再过一秒将setTimeout中的函数添加到任务队列中，然后执行。</p><p>直接执行上面的代码会每隔一秒钟输出一个6，因为到执行setTimeout中的函数时，i已经变成了6（因为循环里每次迭代同时共享着变量i，循环内部创建的函数全都保留了对相同变量的引用），所以会输出6。</p><p>要想实现不同的数字，就需要把每个定时器访问的变量独立起来，这就用到了JS中的闭包。</p><ul><li>使用闭包来解决 - <em>闭包是指有权访问另一个函数作用域中的变量的函数</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 在setTimeout外添加一个立即调用函数表达式，将变量i作为参数传入闭包中</span><br><span class="line">for (var i = 1; i &lt;=5; i++) &#123;</span><br><span class="line">    (function(value) &#123;</span><br><span class="line">            setTimeout( function timer () &#123;</span><br><span class="line">                console.log(i)</span><br><span class="line">            &#125;, i * 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    )(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在循环内部，立即调用函数（IIFE）为接受的每一个变量i都创建了一个副本并存储为变量value。这个变量的值就是响应迭代创建的函数所使用的值，因此调用每个函数都会像从0-9循环一样得到期望的值。</p><ul><li>使用块级作用域let来解决<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">    setTimeout( function timer () &#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;, i * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>每次循环的时候let声明都会创建一个新的变量i，并将其初始化为i的当前值，所以循环内部创建的每个函数都能得到属于它们自己的i的副本。</p><hr><p>参考链接<br><a href="https://segmentfault.com/a/1190000009017901" target="_blank" rel="noopener">setTimeout面试题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。&lt;/p&gt;
&lt;h4 id=&quot;setTimeout&quot;&gt;&lt;a href=&quot;#setTimeout&quot; class=&quot;headerlink&quot; title=&quot;setTimeout&quot;&gt;&lt;/a&gt;setTimeout&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;setTimeout(function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&amp;apos;hello word&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, 1000)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码设置了等待一秒之后弹出警告框。setTimeout有两个参数，第一个是传递一个函数，第二个是毫秒数，在等待设置的毫秒数之后执行函数的操作。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yikeshu.info/categories/JS/"/>
    
    
      <category term="JS" scheme="http://yikeshu.info/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>CSS垂直居中</title>
    <link href="http://yikeshu.info/2018/04/03/CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <id>http://yikeshu.info/2018/04/03/CSS垂直居中/</id>
    <published>2018-04-03T05:20:49.283Z</published>
    <updated>2018-04-03T05:24:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS垂直居中基本上经常需要用到的一个需求，而且面试的时候也有的公司会考察这个问题，但是需要手写出来，所以对于这个老生常谈的问题还是需要记住，下面就是我总结出了几种垂直居中的方法：<br><a id="more"></a></p><h4 id="基于绝对定位的方法"><a href="#基于绝对定位的方法" class="headerlink" title="基于绝对定位的方法"></a>基于绝对定位的方法</h4><p>这种方法采用了绝对定位的方法适用于，固定宽高的模块。废话不说上代码<br>html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;center&quot;&gt;居中文本&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>css<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">    -webkit-transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>原理就是使用绝对定位相对于父元素，左边偏移50%，右边偏移50%，然后再使用<strong><a href="https://www.w3cplus.com/content/css3-transform" target="_blank" rel="noopener">transform</a></strong>中的translate进行位移，translate移动是根据元素中心作为参考值移动的，所以以元素中心为基点，再向左向上移动-50%，此元素就达到居中的效果了。</li></ul><h4 id="table垂直居中"><a href="#table垂直居中" class="headerlink" title="table垂直居中"></a>table垂直居中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;table style=&quot;width=100%&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;这是table垂直居中&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>如果担心语义上的不同，可以使用如下方式<br>html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;table-style&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;table-cell&quot;&gt;table垂直居中&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>css<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.table-style &#123;</span><br><span class="line">    display: table;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.table-cell &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用Flex解决方案"><a href="#使用Flex解决方案" class="headerlink" title="使用Flex解决方案"></a>使用Flex解决方案</h4><p>html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;center&quot;&gt;flex居中&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>css<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">    width：100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">    justify-content: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Flex中的<strong>align-items</strong>定义项目在交叉轴上如何对齐，<strong>center</strong>是交叉轴的中点对齐，而<strong>justify-content</strong>定义了项目在主轴上的对齐方式，<strong>center</strong>在主轴方向居中，两者组合就可以实现垂直居中的效果。</p><hr><p>这就是我总结的三种垂直居中的方法，如何还有更好的方法欢迎交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS垂直居中基本上经常需要用到的一个需求，而且面试的时候也有的公司会考察这个问题，但是需要手写出来，所以对于这个老生常谈的问题还是需要记住，下面就是我总结出了几种垂直居中的方法：&lt;br&gt;
    
    </summary>
    
      <category term="Web" scheme="http://yikeshu.info/categories/Web/"/>
    
    
      <category term="CSS" scheme="http://yikeshu.info/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Position fixed Inner content list 滚动卡顿</title>
    <link href="http://yikeshu.info/2018/01/29/position-fixed-content-scroll/"/>
    <id>http://yikeshu.info/2018/01/29/position-fixed-content-scroll/</id>
    <published>2018-01-29T11:09:26.135Z</published>
    <updated>2018-01-31T09:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做项目的过程中，总是会遇到要实现一个弹出视图，多数需求都是在弹出视图中添加一个滚动列表，使弹出视图撑满整个屏幕，并固定在屏幕上方，一般都会想到使用<code>position: fixed</code> 将top, left, right ,bottom 都设置为0，这样就能撑满整个屏幕，在当前窗口弹出一个固定位置的视图大小，示例如下代码<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">html, body &#123;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.model-fixed-view &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  margin: 30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在<code>.model-fixed-view</code>这个视图已经固定在屏幕上方距离边界30px的位置，那接下来需要在上面加载一个列表，并能滚动例如。<br><img src="http://oybj22zxs.bkt.clouddn.com/scroll-text.png" alt=""></p><p>在html中一般只要内部视图超出屏幕高度，就会自动滚动加载。如下设置一个视图高度很高的样式，来模拟滚动的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.content &#123;</span><br><span class="line">  background-color: blue;</span><br><span class="line">  height: 2000px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>样式展示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;model-fixed-view&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;ddd&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>但是这样写之后会发现一个问题，内部视图虽然已将远远超出父视图的高度，但是内部视图不能滚动加载，即使能滚动加载，在手机上滑动滚动的时候依然很少卡顿，在试了各种办法之后，依然效果不好，网上搜集资料找到了如下解决办法。</p><h4 id="解决fixed-content滑动卡顿，不滑动的问题"><a href="#解决fixed-content滑动卡顿，不滑动的问题" class="headerlink" title="解决fixed content滑动卡顿，不滑动的问题"></a>解决fixed content滑动卡顿，不滑动的问题</h4><p>找了一些办法，只要在设置fixed父视图中添加如下的样式，就可以解决滑动卡顿，滑动不流畅的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.model-fixed-view &#123;</span><br><span class="line">  overflow-y: scroll;</span><br><span class="line">  -webkit-overflow-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考链接：<br><a href="https://css-tricks.com/forums/topic/prevent-body-scrolling-when-the-user-scrolls-on-fixed-position-div/" target="_blank" rel="noopener">https://css-tricks.com/forums/topic/prevent-body-scrolling-when-the-user-scrolls-on-fixed-position-div/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做项目的过程中，总是会遇到要实现一个弹出视图，多数需求都是在弹出视图中添加一个滚动列表，使弹出视图撑满整个屏幕，并固定在屏幕上方，一般都会想到使用&lt;code&gt;position: fixed&lt;/code&gt; 将top, left, right ,bottom 都设置为0，这样就能撑满整个屏幕，在当前窗口弹出一个固定位置的视图大小，示例如下代码&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yikeshu.info/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>Start 2018</title>
    <link href="http://yikeshu.info/2018/01/17/start2018/"/>
    <id>http://yikeshu.info/2018/01/17/start2018/</id>
    <published>2018-01-17T03:59:55.969Z</published>
    <updated>2018-01-17T07:10:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2018年1月17号，至今2018年已经过去半个月了。</p><p>就在昨天我找到了自己喜欢的博客主题，然后就迫不及待的把它安到我自己的博客上，并在此上面做了简单的修改，才成为现在的样子，真的很喜欢这个博客主题，越看越喜欢，现在就越来越想让自己的博客内容丰富起来，已经开始迫不及待的想写文章了，哈哈。<br><a id="more"></a><br>博客搭建到现在已经有一年多了，但上面的文章聊聊无几，写出来能读下去的内容也很少，不得不说我之前真的不会写文章。但自从在2017的下半年，我开始每天用文字记录自己的想法，脑子里想到什么就把它写出来，不知不觉已经记录到现在。而现在我才开始渐渐体会到这样做的好处，一能让自己的脑子更清晰，想到什么就写什么，有时候心烦意乱但写着写着脑子就很清晰了，二来锻炼了自己的文字表达能力，以前总是不会表达自己，而现在可以简单的用文字表达自己的想法了，虽然写的并不算好，但能表达出自己的想法也是不小的进步，要知道我之前根本不会表达自己的想法，太沉默了。</p><p>2018年，虽然现在还是和以前一样上班下班，每天还在为吃什么而发愁，但现在回首这十几天的生活给我的感觉是，过去的每一天都很充实。</p><p>要说2018年最大的改变就是，开始每天写效率手册，开始每天记录自己的生活。效率手册是潇洒姐发明的，手册每一页都是已经排版好的样式，每天只要在上面写就可以了。早晨起床之后的第一件事情就是写效率手册，计划好这一天要做的事情，晚上睡前的最后一件事就是在效率手册记下这一天的收获，自己做了哪些事情。在每月的开始都有一整页的空白，可以写下自己的月计划。本子的最后一页是用来写自己的一生计划，一生计划听着好像很长似的，但它可以拆成两年三年的计划，写最近两年或者三年、五年都可以，我是计划不了那么长远的未来，现在写的是未来两年的计划。这个我也想了好久，直到去写下来，才知道自己从来都没想过，以后的生活会是什么样，自己要成为什么样的人，在没有这个计划之前，一直是船到桥头自然直，虽然这样也可以活着，但自从开始了这个计划之后，生活有了目标，就少了很多的无病呻吟和烦恼，为了自己的计划和未来美好的生活，心中有了目标，走的也会更坚毅，现在的每一天都会为达到自己的目标而更努力，每一天都量化了，可以很直观的看到自己进步了多少，做了多少努力，看了多少书。有了这个效率手册确实对我的帮助很大，清楚了自己做了些什么，才发现自己一直都很努力，积极乐观。现在只过了短短的半个月时间，每天写效率手册成了我最快乐的事情，每一天都记录自己的生活，这样到年底就能有效的评估自己和梦想之间的距离，看到自己每一天走过的路都是那么充实和快乐，就像手册上第一句话写的那样 —— —— “时间看得见”</p><p>2018年我还坚持早起，现在是冬季，计划是每天早晨6点起床，虽然不是很早，但相比于之前八点起床还是多了两个小时的时间，去年也计划过早起，但往往坚持两三天就放弃了，而现在坚持早起已经十五天了，偶尔一两次懒床起不来，我也不再像之前那样懊恼自己起不来了，在了解了自己为什么起不来的原因之后，都能很快的原谅自己，下次再做好就是了。每一天都不同，总会有特殊的情况扰乱计划，而我也不像之前懊恼自己的计划失败，而在心里责怪自己。就因为某一天的失败而让整个早起计划失败掉，是得不偿失的，这一次没做好，争取下一次做到更好就是了，这是一项长期计划，一年三百六十五天不可能做到每一天都完美，关键是接受自己的不完美，明白什么才是对自己最重要的。</p><p>这是一个很好的开始，2018一定很精彩，一起期待吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2018年1月17号，至今2018年已经过去半个月了。&lt;/p&gt;
&lt;p&gt;就在昨天我找到了自己喜欢的博客主题，然后就迫不及待的把它安到我自己的博客上，并在此上面做了简单的修改，才成为现在的样子，真的很喜欢这个博客主题，越看越喜欢，现在就越来越想让自己的博客内容丰富起来，已经开始迫不及待的想写文章了，哈哈。&lt;br&gt;
    
    </summary>
    
      <category term="Thking" scheme="http://yikeshu.info/categories/Thking/"/>
    
    
  </entry>
  
  <entry>
    <title>理解JavaScript中的闭包</title>
    <link href="http://yikeshu.info/2017/08/11/%5B%E8%AF%91%5D%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <id>http://yikeshu.info/2017/08/11/[译]理解JavaScript中的闭包/</id>
    <published>2017-08-11T12:27:57.000Z</published>
    <updated>2018-04-14T14:45:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>闭包并不复杂。学习和理解闭包的基础知识仅仅只需要10分钟。</p><h4 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h4><p>闭包是JavaScript的一部分，每个工程师都应该知道和理解闭包。今天的文章只是撇开闭包的表面，但是将会给你一个很好的思想，关于什么是闭包和它在JavaScript中是如何运行的。好了，接下来我们开始吧。<br><a id="more"></a><br>我们先从书本中闭包的定义开始。</p><h4 id="定义1"><a href="#定义1" class="headerlink" title="定义1"></a>定义1</h4><blockquote><p>闭包是一个能访问父作用域的函数，即使此作用域关闭了。</p></blockquote><h4 id="定义2"><a href="#定义2" class="headerlink" title="定义2"></a>定义2</h4><blockquote><p>闭包是一个函数和该函数被声明的词汇环境的组合。</p></blockquote><p>很好，但是这些真正的意思是什么？</p><p>首先你需要理解在JavaScript中的<strong>作用域</strong>，作用域实质上是变量在JavaScript中的生命周期。因此，当一个变量定义了一个大的作用域，这个变量会存活多久，那个方法在你的程序中会访问到它。</p><p>让我们看一个例子。</p><p>当你在JavaScript中创建一个函数，它可以访问创建在这个函数里面和外面的变量。</p><p>变量创建在一个函数中也定义了这个变量。一个局部变量只能在这个被定义的函数里面访问到。在下面这个例子中，你将会看到如果我们尝试在这个函数外面打印<code>words</code>，它会输出错误信息。这是因为<code>words</code>是一个内部作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak () &#123;</span><br><span class="line">  var words = &apos;hi&apos;;</span><br><span class="line">  console.log(words);</span><br><span class="line">&#125;</span><br><span class="line">speak(); // hi</span><br><span class="line">console.log(words); // undefined</span><br></pre></td></tr></table></figure><p>和上一个例子不同，这次我们定义这个words 为全局作用域。<br>意思是说我们可以在任何函数中访问这个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 将变量放到函数的外面</span><br><span class="line">// words 现在是个全局变量</span><br><span class="line">var words = &apos;hi&apos;;</span><br><span class="line">function speak()&#123; </span><br><span class="line">  console.log(words);</span><br><span class="line">&#125;</span><br><span class="line">speak(); // &apos;hi&apos; </span><br><span class="line">console.log(words); // &apos;hi&apos;</span><br></pre></td></tr></table></figure><h4 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h4><p>我们将一个函数放到另一个函数里面会发生什么？我想你跟着操作下面的例子，因为这个会很有趣！</p><p>如果你使用谷歌浏览器，打开你的开发工具调试模式：<br>[Windows]：Ctrl + Shift + J<br>[MAC]：Cmd + Opt + J</p><p>Cool，现在拷贝下面的代码然后粘贴到你的控制台中。我们现在做的是创建一个名字为<code>speak</code>的函数。<code>speak</code>返回一个名称为<code>logIt</code>的函数。最终<code>logIt</code>在控制台中打印log值为<code>words</code>，在这个实例要实现在控制台中输出 <code>‘hi’</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">  return function logIt() &#123;</span><br><span class="line">    var words = &apos;hi&apos;;</span><br><span class="line">    console.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你拷贝到这段代码到你的控制台中，我们将要创建一个变量，然后将speak函数赋值给它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sayHello = speak();</span><br></pre></td></tr></table></figure></p><p>现在我们可以看见这个变量<code>sayHello</code> 调用了之后，没有执行内部函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sayHello;</span><br><span class="line">//  function logIt() &#123;</span><br><span class="line">//    var words = &apos;hi&apos;;</span><br><span class="line">//    console.log(words);</span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure></p><p>如上打印的结果，<code>sayHello</code> 打印的是我们return的内部函数，也就是说，如果我们执行<code>sayHello()</code>在控制台中，它将会唤起执行<code>logIt()</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sayHello();</span><br><span class="line">// &apos;hi&apos;</span><br></pre></td></tr></table></figure></p><p>它奏效了，但是并没有任何特别。让我们移除一行代码看看什么发生了改变。请看下面的示例。我们将清楚定义的变量<code>words</code>移到<code>speak()</code>函数的里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">  var words = &apos;hi&apos;;</span><br><span class="line">  return function logIt() &#123;</span><br><span class="line">    console.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像之前的操作，让我们定义一个变量并将speak函数赋值给它:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sayHello = speak();</span><br></pre></td></tr></table></figure></p><p>现在我们看看我们的 sayHello变量会输出什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHello</span><br><span class="line">//  function logIt() &#123;</span><br><span class="line">//    console.log(words);</span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure></p><p>哦，这里没有<code>words</code> 变量的定义，那么发生了什么当我们执行这个函数的时候？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sayHello();</span><br><span class="line">// &apos;hi&apos;</span><br></pre></td></tr></table></figure></p><p>它仍然起作用了！这是因为你刚刚体验了闭包的影响。</p><p>是否有点疑惑？没关系，回想下我们的闭包的定义：</p><blockquote><p>闭包是一个能访问父作用域的函数，即使此作用域关闭了。</p></blockquote><p>在这个例子中我们的<code>speak()</code>函数作用域关闭了。这意味着 <code>var words = &#39;hi&#39;</code> 应该消失了。然而，在JS中我们有一个名称将这种现象叫做闭包：<strong><em>我们的内部函数保持对其创建的范围的引用</em></strong>。这就允许<code>logIt()</code>函数仍然可以访问<code>words</code>这个变量——即使<code>speak()</code>这个函数作用域关闭了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">  var words = &apos;hi&apos;;</span><br><span class="line">  return function logIt() &#123;</span><br><span class="line">    console.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>重要提示，在JavaScript中每个函数都有一个闭包。你不需要你去解释闭包在函数中是怎么运行的，它仅仅只是JavaScript的一部分。</p></blockquote><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p>让我们查看另一个例子。这个例子有点复杂，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function name(n) &#123;</span><br><span class="line">  return function(a) &#123;</span><br><span class="line">    return `$&#123;n&#125; likes $&#123;a&#125;`;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们定义了一个名字为<code>name</code> 的函数可以传递一个参数，返回一个匿名函数，可以传递一个不同的参数，内部函数返回一个字符串。</p><p>我们用<code>name</code>函数创建两个变量。一个我们给name函数传递 John，另一个传 Cindy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var j = name(&apos;John&apos;);</span><br><span class="line">var c = name(&apos;Cindy&apos;);</span><br></pre></td></tr></table></figure></p><p>让我们看看<code>j</code>现在能打印什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j;</span><br><span class="line">//  function (a) &#123;</span><br><span class="line">//    return `$&#123;n&#125; likes $&#123;a&#125;`;</span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure></p><p>所以根据之前示例我们知道这是因为闭包，这个函数应该仍然可以访问<code>n</code>的变量通过父作用域。我们所能做的是把<code>a</code>传递过去，在执行函数的时候。</p><p>让我们试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j(&apos;dogs&apos;);  // &apos;John likes dogs&apos;</span><br><span class="line">c(&apos;cats&apos;);  // &apos;Cindy likes cats&apos;</span><br></pre></td></tr></table></figure></p><p>成功了！因为闭包我们才能从之前关闭的作用域引用变量成功的执行我们的函数。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望你现在可以理解基本的闭包在JavaScript和它是如何运行的！这虽然只是冰山一角，但明白了基础知识才能学习和练习更复杂的闭包。</p><hr><p>翻译原文链接：<a href="https://codeburst.io/understand-closures-in-javascript-d07852fa51e7" target="_blank" rel="noopener">https://codeburst.io/understand-closures-in-javascript-d07852fa51e7</a><br>翻译中有疏漏的地方，欢迎指正。</p><p>校对：蹦蹦</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包并不复杂。学习和理解闭包的基础知识仅仅只需要10分钟。&lt;/p&gt;
&lt;h4 id=&quot;什么是闭包？&quot;&gt;&lt;a href=&quot;#什么是闭包？&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包？&quot;&gt;&lt;/a&gt;什么是闭包？&lt;/h4&gt;&lt;p&gt;闭包是JavaScript的一部分，每个工程师都应该知道和理解闭包。今天的文章只是撇开闭包的表面，但是将会给你一个很好的思想，关于什么是闭包和它在JavaScript中是如何运行的。好了，接下来我们开始吧。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yikeshu.info/categories/JS/"/>
    
    
      <category term="JS" scheme="http://yikeshu.info/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>解决Chrome不能播放mp4视频的问题和HLS视频播放</title>
    <link href="http://yikeshu.info/2017/08/11/%E8%A7%A3%E5%86%B3Chrome%E4%B8%8D%E8%83%BD%E6%92%AD%E6%94%BEmp4%E8%A7%86%E9%A2%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8CHLS%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/"/>
    <id>http://yikeshu.info/2017/08/11/解决Chrome不能播放mp4视频的问题和HLS视频播放/</id>
    <published>2017-08-11T12:25:12.000Z</published>
    <updated>2017-08-11T12:57:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在面临一个问题chrome中播放后缀名为.mp4的视频文件只有声音播放不出视频画面，上网查了一下才知道，MP4视频不是说后缀名以.mp4结尾的就是MP4视频，mp4视频还包括不同的编码格式，还有不同的扩展名，都可以统一定义成MP4文件，而chrome只支持标准的H.264方式的编码，所以如果视频编码格式不对，chrome还是加载不出来的。<br><a id="more"></a><br>想要查看视频的编码格式，最简单查看视频信息的方式是，在文件中选中视频点击右键查看简介或者详细信息，下面有一个栏信息是编解码器：标准的编码格式是H.264，如果不是这种格式，那很抱歉chrome加载不出来是正常的。</p><p>为什么chrome只支持H264这种格式呢，而不支持所有的视频编码格式？查了一下大概是说，绝大部分的视频编码格式都是要付专利费的，Google已经买了H264编码格式，所以其他的就不买了，Firefox没有Google那么有钱不愿意买。不过它使用Flash，绝大部分的视频格式基本上可以通过Flash播放。</p><p>而我司解决办法是，将MP4视频文件转码统一转成hls格式编码的视频，这种格式的视频后缀名是以.m3u8结尾的。</p><h4 id="什么是HLS？"><a href="#什么是HLS？" class="headerlink" title="什么是HLS？"></a>什么是HLS？</h4><p>HTTP Live Streaming（简称HLS）是一个基于HTTP的视频流协议，由苹果公司实现，</p><p>HTTP流媒体直播(HLS)是一种基于HTTP的媒体流媒体通信协议，由苹果公司实施，作为QuickTime、Safari、OS X和iOS软件的一部分。它的工作原理是将整个流程分解成一个小的基于http的文件下载序列，每个下载都加载了一个完整的潜在无界传输流的一小块。</p><h4 id="什么m3u8"><a href="#什么m3u8" class="headerlink" title="什么m3u8"></a>什么m3u8</h4><p>先说说M3U，M3U是一种播放多媒体列表的文件格式，它的设计初衷是为了播放音频文件比如MP3,但是越来越多的软件现在用来播放视频文件列表，M3U也是可以指定在线留媒体音频源。很多播放器和软件都支持M3U文件格式。</p><p>M3U8是Unicode版本的M3U，用UTF-8编码。’M3U’和M3U8‘文件都是苹果公司使用的HTTP Live Streaming格式的基础，这种格式可以在iPhone和Macbook等设备播放。</p><h4 id="平台支持情况"><a href="#平台支持情况" class="headerlink" title="平台支持情况"></a>平台支持情况</h4><p>苹果的产品都能很好的支持，iPhone、Safari，但是在chrome和Firefox还有一些其他未知的浏览器不支持播放这种视频格式。</p><p>So，想要播放这种格式的视频，前端这块还要做一层处理，不过不用担心，已经有人帮我们造好轮子了，Github上有很好的库可以支持这种视频格式的播放，<a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">VideoJs</a>,<a href="https://github.com/videojs/videojs-contrib-hls" target="_blank" rel="noopener">videojs-contrib-hls</a><br>集成起来也非常的简单，github上都给了一些示例。</p><h4 id="快速集成开发"><a href="#快速集成开发" class="headerlink" title="快速集成开发"></a>快速集成开发</h4><p>在<code>head</code>头中引入如下的CDN，需要引入videojs的样式，是为了使用播放器的样式，要不然播放器会很难看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;//vjs.zencdn.net/5.19/video-js.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;script src=&quot;//vjs.zencdn.net/5.19/video.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.8.3/videojs-contrib-hls.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;video id=&quot;video-play&quot; class=&quot;video-js vjs-default-skin&quot;</span><br><span class="line">      style=&quot;width: 600px; height: 400px;&quot;</span><br><span class="line">      playsinline webkit-playsinline</span><br><span class="line">      controls preload=&quot;auto&quot;</span><br><span class="line">      x-webkit-airplay=&quot;true&quot; controlsList=&quot;nodownload&quot; oncontextmenu=&quot;return false&quot;&gt;</span><br><span class="line">      &lt;source src=&quot;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt;</span><br><span class="line">    &lt;/video&gt;</span><br><span class="line">    &lt;button&gt;播放&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var el = document.getElementById(&quot;play-btn&quot;)</span><br><span class="line">    el.addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">        window.videojs(&apos;video-play&apos;, &#123;&#125;, function onPlayerReady () &#123;</span><br><span class="line">         this.play()</span><br><span class="line">         this.on(&apos;ended&apos;, function () &#123;</span><br><span class="line">             console.log(&apos;ended, video js&apos;)</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h4><ul><li>MP4视频编码格式有哪几种<br>MP4视频格式包括：MPEG-4 SP(Simple Profile/简单类)/ASP(Advanced Simple Profile/高级简单类)：xvid, divx5, 3ivx,ffmpeg/ffdshow, NeroDigital ASP…及MPEG-4 AVC/H.264：x264, NeroDigital AVC, Apple…还有MPEG-2, MPEG-1（不含Divx3/M$ MPEG4, WM9, RV9或VP6）.-</li></ul><hr><p>参考链接：<br>Mp4编码全介绍：<a href="https://my.oschina.net/alphajay/blog/4276" target="_blank" rel="noopener">https://my.oschina.net/alphajay/blog/4276</a><br><a href="http://www.jianshu.com/p/52c569efbfc0" target="_blank" rel="noopener">http://www.jianshu.com/p/52c569efbfc0</a><br><a href="https://imququ.com/post/html5-live-player-1.html" target="_blank" rel="noopener">https://imququ.com/post/html5-live-player-1.html</a><br><a href="http://yanhaijing.com/html/2016/03/12/html5-video/" target="_blank" rel="noopener">http://yanhaijing.com/html/2016/03/12/html5-video/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在面临一个问题chrome中播放后缀名为.mp4的视频文件只有声音播放不出视频画面，上网查了一下才知道，MP4视频不是说后缀名以.mp4结尾的就是MP4视频，mp4视频还包括不同的编码格式，还有不同的扩展名，都可以统一定义成MP4文件，而chrome只支持标准的H.264方式的编码，所以如果视频编码格式不对，chrome还是加载不出来的。&lt;br&gt;
    
    </summary>
    
      <category term="WEB" scheme="http://yikeshu.info/categories/WEB/"/>
    
    
  </entry>
  
  <entry>
    <title>职场主动</title>
    <link href="http://yikeshu.info/2017/07/01/jobInitiative/"/>
    <id>http://yikeshu.info/2017/07/01/jobInitiative/</id>
    <published>2017-07-01T14:24:49.000Z</published>
    <updated>2018-01-17T03:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近喜欢看美国的一个真人秀节目—《学徒》，《学徒》是美国全国广播公司出品的一档职场创业型真人秀节目，这档节目的制作人是纽约的地产大亨唐纳德•特朗普（DonaldTrump）也就是现在的美国总统，他从全美21万多志愿者中选择16名学徒候选人加入比赛，这些被选拔出的选手们则要为了获得特朗普旗下的一个商业项目的经营机会而展开竞争。这个节目04年的时候开始播出，第一季一播出就风靡了全美国，连续四个月位居收视冠军宝座，平均家庭收视数位2070万，最高家庭收视数达4010万，成为五年来18——49岁成年任收视率最高的节目。我也是出于对特朗普的好奇，才开始看这期节目。<br><a id="more"></a><br>这两天刚看了第二季的第一集，所有征集来的参赛者将面临第一次竞争，首先将男生和女生各分成一组，两组展开竞争，这一次稍有点不同，按照男女分好组之后，要求男生组选出一个人去当女生队的队长，女生队选出一个人去当男生队的队长，说实话选出一个人比较难，去到任何一队都会很艰难，同性别的人很好交流，首先性别相同就很容易找到共同话题，而在当时的环境下，大家相处紧紧只有几个小时，要选出一个人去当他们的队长，还要去管理他们，如果我是身处在女性团队中的一个人，我是不愿意站出来说，我去他们组，真的这很艰难。但他们但凡被挑选出来一定有很强的能力，也是一群聪明人，商讨了一下，每一队都有人主动站出来，主动去担当其他队的队长，这是一个好机会，也是一个不小的挑战，如果失败就会面临被开除的风险。</p><p>他们这次执行的任务是，在玩具公司，为他们提供各种资源，各设计一款玩具，最后由专业人士评选出谁更受欢迎，受欢迎的那组获胜。整个设计过程不再细说了，只说我印象深刻的一点，其实也是我最关注的一点就是，其中一个团队失败了，在会议室见川普的那一刻，决定开除谁的那一刻。</p><p>这一集男生队失败了，在会议室里川普问在场的队员，觉得谁做的比较差，如果开除掉一个人你会开除谁，大家说的最多的就是罗杰，觉的他没有为整个团队做多大的贡献，而问罗杰：“你为什么没有为团队贡献”，他说是因为队长没有为他分配任务。罗杰是个典型的被动型人才，如果队长没有给他分配任务，他就觉得这个事情无从下手，本来面对一个大家不熟悉的玩具行业，大家也是摸着石头过河，各尽其能，而队长其实也没有将任务分配给各个人，说你要做什么，你去做什么，大家都做什么，相处的时间很短暂，大家互相了解的都不够，作为一个管理人员，是不可能分工明细，做到每个人都分配到任务。在这种情况下，就应该更主动一点，提出自己的想法，尽自己的一份力，而不是要让别人告诉你要做什么，不要做什么。罗杰肯定是一个好员工，但他缺少主动性，总是要让别人告诉你，你要去做什么，这样就会让机会白白的溜走。最后川普终于对他说出了那句话：“You are fired!”</p><p>职场中要想提高自己，是最不能缺少主动性的场所，反思一下我在工作中也是极度缺乏主动性的一个人，在工作中比如说有什么需求，就做这个需求，做完了就完了，明知道自己写的代码还有很多优化的空间，但就是不愿意主动提出来去修改，最明显的一个例子是，现在有个需求，只是修改一个小问题，已经提出来了，我当时也没有什么要紧的事，而我的另一个同事也在忙一些手头上不紧急的事情，但总是在我犹豫要不要做接这个需求的时候，他总是很主动的说交给我吧，每当线上出现问题的时候，他总是第一个出来询问现象，找到问题然后解决掉，年纪虽然不大，初入职场不久，看这势头以后前途无量啊。现在整个团队都很信任他，我虽然工作时间比较长了，但做什么事缺乏主动性，比较犹豫，一直把自己当成一个打工仔来思考问题，组长分配你什么任务就做什么，超过自己的需求范围一概不管，我这种虽然能把手头上的事情做好，但也仅限手头上的事而已，要想有所提升，在团队中提高自己的能力和信任感，还需要更主动的多做一些事情，多承担一些责任，做的越多对业务越熟练也就能越快的解决问题。</p><p>虽然这个节目只是为了赚钱、为特朗普选拔人才，但可以看到真实的商场和职场人的真实状态，从中学习到的职场思维，和如何在一群比你更聪明的人中脱颖而出，面对机会的时候，紧紧的抓住并主动出击，机会并不会求着你让你收下它，如果不争取它就会从你身边溜走。我相对来说面对职场这种丛林法则，自己的经验还是偏少，处理不好人际关系，缺少沟通交流的经验，还停留在学生思维，有人给你留作业，就认真完成，然后交作业。但在工作中不可能事无巨细的任何事情都给你安排好了，业务很紧急任务很多的时候，没有人顾得上你，先将自己该做的事情做好，然后更主动一点，才能在职场上有所成长晋升。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近喜欢看美国的一个真人秀节目—《学徒》，《学徒》是美国全国广播公司出品的一档职场创业型真人秀节目，这档节目的制作人是纽约的地产大亨唐纳德•特朗普（DonaldTrump）也就是现在的美国总统，他从全美21万多志愿者中选择16名学徒候选人加入比赛，这些被选拔出的选手们则要为了获得特朗普旗下的一个商业项目的经营机会而展开竞争。这个节目04年的时候开始播出，第一季一播出就风靡了全美国，连续四个月位居收视冠军宝座，平均家庭收视数位2070万，最高家庭收视数达4010万，成为五年来18——49岁成年任收视率最高的节目。我也是出于对特朗普的好奇，才开始看这期节目。&lt;br&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://yikeshu.info/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>小白健身第一周</title>
    <link href="http://yikeshu.info/2017/03/05/%E5%B0%8F%E7%99%BD%E5%81%A5%E8%BA%AB%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
    <id>http://yikeshu.info/2017/03/05/小白健身第一周/</id>
    <published>2017-03-05T10:49:31.000Z</published>
    <updated>2018-01-17T07:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>三月不减肥，五月徒伤悲。夏天来了，开始甩掉身上多余的赘肉，减肥！减肥！。正好附近有个健身房，办了张健身卡开始我的健身甩脂运动吧！<br><a id="more"></a></p><h4 id="制定健身计划"><a href="#制定健身计划" class="headerlink" title="制定健身计划"></a>制定健身计划</h4><p>对于小白的我第一次去健身房看到那么多器械完全是一脸懵逼的状态，到底要从哪里开始呢，这个器械要怎么操作锻炼的部位是哪里呢，完全一脸懵逼什么都不懂。没办法没钱请私教只能自己从网上找资料做笔记，根据自己的时间来安排制定健身计划。keep上有一个健身房入门女生版，看了几遍视频决定就先从这些简单的固定器械开始练习吧。</p><p>一周七天计划最少最少要去锻炼三次，本来计划是一三五、六日再去一天，这样就能有四天的锻炼时间，但是星期一第一天就没有实现。星期一按照平常的下班时间是六点四十左右，这样我到家的时间就是7点左右，这时再去健身房还不算太晚，然后再锻炼一个半小时大概八点半，就可以回家了。但没想到的是忘记考虑加班了，那天一直到加到七点多才下班，然后匆匆忙忙的找小黄车，找到好几个都是坏的没法骑了，我只好快步走回去了，到家大概7点四十左右，瞬间不想去健身房了，头也很痛。在多次斗争过后，还是懒癌细胞胜利了，放弃了去健身房，决定在家跳会HIIT，这也算运动了。最后计划调整为每周二四六必须去不得有任何的商量。周二依然加班到七点才走，但不能给自己任何的狡辩了，就算八九点了也要去健身房锻炼，不管锻炼了多久只要去了就可以，先养成去健身房锻炼身体的习惯，不能让自己那么胆怯害怕去健身房。</p><h4 id="健身房锻炼的体验"><a href="#健身房锻炼的体验" class="headerlink" title="健身房锻炼的体验"></a>健身房锻炼的体验</h4><p>总的来说，每次决定去的时候很纠结很艰难，像两方军队在打仗谁胜利了就听谁的。后来我不想思考到底是去还是不去了，既然计划了时间和地点只管换上运动鞋运动服去就好了，不要多想。这个星期还是按照自己原先调整规划好的时间去的，周二周四周六这三天，第一次只骑了20分钟的单车，第二次玩了几个简单的器械锻炼腿部的背部胸部之后再跑了30分钟，整个流程走下来已经很累了。刚开始主要是适应性训练，熟悉器械和健身房周围的环境，我不想刚开始就让自己以后再也不想去了。周六晚上去的时候人很少正好前两天一起聊天的一个教练有空，他看见我在练说要指导指导我的动作，就这样练了几组加了重量，这次练的时候比前两次都重，所以练的时候更吃力，还经过了专业的指导，动作也标准了些，所以练的更到位，身体并没有不适的感觉反而更舒服了，然后去做了半个小时的有氧运动，最后拉伸身体，锻炼完成，这个星期的任务就结束了。这三次的锻炼一次比一次的训练增强，我的运动能力也慢慢的提高了，身体好像被唤醒了一样，以前总是感觉昏昏沉沉的做什么都没有精神，自从开始锻炼以后整个人都发生了变化，精力更充沛了，也没有那种总睡不够的感觉了。工作也能更好的应对，虽然每次只花了一个半小时的时间，但我个人的精神状态，做事的效率都更好的提高了。每次锻炼完成之后虽然很累，但心情是愉悦的，也能体会到运动的乐趣。为了更美好的自己，加油加油！</p><h4 id="这几天的心得"><a href="#这几天的心得" class="headerlink" title="这几天的心得"></a>这几天的心得</h4><ul><li><p>记住当你计划好做一件事情的时候，不可能永远那么顺利，总会有突发状况等着你，延误了执行的时间，但不要心烦意乱，重要的是能在突发状况下依然坚持去执行。</p></li><li><p>不是说办了张健身卡身上的肉就能自然而然的掉下去，还要自己主动的去健身房锻炼，利用哪里的设备科学的锻炼自己的身体。没钱请私教就从网上学习，也要根据自己的身体条件选择合适的锻炼方式。好的身材都是靠练出来的，不断的锻炼才能达到目标。</p></li><li><p>我知道坚持锻炼很难，但当你把时间地点都想好以后，只管按照计划做就好了，什么都不要多想。像我计划下班之前在公司喝一杯酸奶或者一杯燕麦，这样晚餐解决了，下班回到家之后换好运动服直接去健身房，去到之后先热身然后练器械做几组，之后做有氧40分钟。这是我的计划，在脑海中模拟了几遍情景，每次时间到了潜意识就会知道该做什么了，直接做就好了不要多想。</p></li></ul><p>加油！科学的锻炼方法加上健康的饮食，就算达不到火辣的身材，也能收获健康的身体。健身第一周，感觉还不错，不得不鼓励鼓励自己做的很好，Good Job！O(∩_∩)O哈哈~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三月不减肥，五月徒伤悲。夏天来了，开始甩掉身上多余的赘肉，减肥！减肥！。正好附近有个健身房，办了张健身卡开始我的健身甩脂运动吧！&lt;br&gt;
    
    </summary>
    
      <category term="Fitness" scheme="http://yikeshu.info/categories/Fitness/"/>
    
    
  </entry>
  
  <entry>
    <title>oneDay</title>
    <link href="http://yikeshu.info/2017/02/18/oneDay/"/>
    <id>http://yikeshu.info/2017/02/18/oneDay/</id>
    <published>2017-02-18T09:56:16.000Z</published>
    <updated>2018-01-17T07:20:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 一日就是一生<br>                 —–（日）酒井雄哉</p><p>修行的每天早上，我都穿着草鞋出去。上山10公里之后，接着走10公里较平坦的路，最后是10公里的下坡路，如此这般每天重复。结束一天的登山行程后，草鞋往往变形、穿烂，隔天得穿上新鞋才行。<br>     日复一日地不断重复。有一天，我发现草鞋就像我自己。当脱掉草鞋的那一刻，今天的自己既以告终。然后，为了明天的重生而认真反省。这么一来，便能获得新生，重新出发。今天的自己，今天就结束，明天将诞生一个全新的自己。<br>     一日就是一生。<br><a id="more"></a></p></blockquote><p>  对于我们普通人来说，今天或许和昨天没有什么不同，每一天都在重复昨天做过的事情，生活对我们大多数人来说就是不断的重复昨天。有时会疲倦，有时也会茫然，但生活还得继续，不会因为你的小情绪，而迁就着你。身边的环境是不会改变的，唯一能改变的就是自己，努力去发现生活中的美，时刻反省自身，不断提醒自己过去的已经过去，每一日都是一个全新的自己，当你用全新的眼光观察世界，会发现每一天，每一个人都不同。五月来了，今天早上去上班意外的发现小区栅栏上的蔷薇开了，黄色的，红色的，粉色的，甚是好看，才发现每天匆匆忙忙的脚步一直往前走，竟然错过了这份美景，错过了一份好心情(<em>^__^</em>) </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 一日就是一生&lt;br&gt;                 —–（日）酒井雄哉&lt;/p&gt;
&lt;p&gt;修行的每天早上，我都穿着草鞋出去。上山10公里之后，接着走10公里较平坦的路，最后是10公里的下坡路，如此这般每天重复。结束一天的登山行程后，草鞋往往变形、穿烂，隔天得穿上新鞋才行。&lt;br&gt;     日复一日地不断重复。有一天，我发现草鞋就像我自己。当脱掉草鞋的那一刻，今天的自己既以告终。然后，为了明天的重生而认真反省。这么一来，便能获得新生，重新出发。今天的自己，今天就结束，明天将诞生一个全新的自己。&lt;br&gt;     一日就是一生。&lt;br&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://yikeshu.info/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>读《三体》</title>
    <link href="http://yikeshu.info/2017/02/18/%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yikeshu.info/2017/02/18/三体读书笔记/</id>
    <published>2017-02-18T09:56:03.000Z</published>
    <updated>2018-01-17T06:54:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从买了kindle 读的第一本书就是三体，身边好多人都说很好看，由于很好奇想看看它到底有多好看，结果一看就无法自拔，被它深深的吸引。由于平常上班还有别的事情要做，唯一能够支配的时间就是上下班路上了，每天只能在地铁上看一会，一直看了一个多月吧，才把三部看完。这个故事很长，但真的很精彩.</p><a id="more"></a><p>故事从我们现在的生活开始，到发现外星文明的入侵，人类如何应对，再到整个宇宙。仿佛就是我们身边发生的事情，距离我们并不遥远。第一步中出现的三体游戏，必须穿上V装备才能玩，V装具可以模拟游戏场景中的环境，比如在游戏中是很热的天气，你也可以感受到热量，如果很冷你也能感受到很冷，确实是一个很棒的体验，我们现在也有VR技术，只能通过带上眼镜才能看到虚拟场景，还处于初步阶段，没准以后技术成熟，也会开发出三体小说中的V装具，更真实的体验游戏世界。</p><p>书中好多地方的论证都是基于现在的物理基础知识，电磁波，引力波，天体物理知识运用的轻车熟路，不得不佩服作者知识的广度和深度，如果说是什么影响我让我对天文感兴趣的，那一定非《三体》这部作品莫属了。当我们仰望星空，是不是在另一个世界，另一个宇宙中也有生命活动的物体做着同样的事情。我相信有外星人的存在，宇宙这么大，而我们身处的太阳系只是冰山一角，放眼到整个宇宙只是一颗普通的星星，在茫茫宇宙之中一定有一个星球也适合生命生存，可能离我们很遥远，但我们并不孤单。</p><blockquote><p>那你的生活是一种偶然，世界有这么多变幻莫测的因素，你的人生却没什么变故。</p></blockquote><p>这个世界每一天都有那么多变化莫测的因素，如果一个人的一生都没有什么变故，确实是一种偶然</p><blockquote><p>也许，人类和邪恶的关系，就是大洋与漂浮与其上的冰山的关系，它们其实是同一种物质组成的巨大水体，冰山之所以被醒目地认出来，只是由于其形态不同而已，而它实质上只不过是这整个巨大水体中极小的一部分…人类真正的道德自觉是不可能的，就像他们不可能拔着自己的头发离开大地。要做到这一点，只有借助人类之外的力量。</p></blockquote><p>这是故事的主人公叶文洁，对人类彻底失望后，想借助外星文明，三体世界来改造这个让她失望的世界。</p><blockquote><p>这想法让我的后半辈子有一种很矛盾的心态：有时觉得生命珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值一提。反正日子就在这种奇怪的感觉中一天天过去，不知不觉就老了….</p></blockquote><p>人真的很渺小</p><blockquote><p>大部分人的爱情对象也只是存在于自己的想象之中。他们所爱的并不是现实中的他（她），而只是想象中的他（她），现实中的他（她）只是他们创造梦中情人的一个模板，他们迟早会发现梦中情人与模板之间的差异，如果适应这种差异他们就会走到一起，无法适应就分开，就这么简单。你与大多数人的区别在于：你不需要模板。</p></blockquote><p>大部分的爱情只是存在于自己的想象之中，很有道理</p><blockquote><p>文明像一场五千年的狂奔，不断的进步推动着更快的进步，无数的奇迹催生出更大的奇迹，人类似乎拥有了神一般的力量…但最后发现，真正的力量在时间手里，留下脚印比创造世界更难，在这文明的尽头，他们也只能做远古的婴儿时代做过的事情。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从买了kindle 读的第一本书就是三体，身边好多人都说很好看，由于很好奇想看看它到底有多好看，结果一看就无法自拔，被它深深的吸引。由于平常上班还有别的事情要做，唯一能够支配的时间就是上下班路上了，每天只能在地铁上看一会，一直看了一个多月吧，才把三部看完。这个故事很长，但真的很精彩.&lt;/p&gt;
    
    </summary>
    
      <category term="Read" scheme="http://yikeshu.info/categories/Read/"/>
    
    
  </entry>
  
  <entry>
    <title>数据存储 NSUserDefaults</title>
    <link href="http://yikeshu.info/2017/02/18/nsuserdefaults/"/>
    <id>http://yikeshu.info/2017/02/18/nsuserdefaults/</id>
    <published>2017-02-18T09:55:09.000Z</published>
    <updated>2018-01-17T07:19:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>NSUserDefaults对象是用来保存，恢复应用程序相关的偏好设置，配置数据等等。默认系统允许应用程序自定义它的行为去迎合用户的喜好。你可以在程序运行的时候从用户默认的数据库中读取程序的设置。同时NSUserDefaults的缓存避免了在每次读取数据时候都打开用户默认数据库的操作。可以通过调用synchronize方法来使内存中的缓存与用户默认系统进行同步。<br><a id="more"></a></p><h4 id="存数据"><a href="#存数据" class="headerlink" title="存数据"></a>存数据</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取NSUserDefaults 对象</span></span><br><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">      <span class="comment">// 存数据，不需要设置路径，NSUserDefaults 将数据保存在preferrences目录下</span></span><br><span class="line">[userDefaults setObject:<span class="string">@"Jane"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">[userDefaults setObject:<span class="string">@"phone"</span> forKey:<span class="string">@"1892233232"</span>];</span><br><span class="line">    <span class="comment">// 立刻保存同步数据，（如果不写这句话，会在将来某个时间点将数据保存在preference目录下）</span></span><br><span class="line">[userDefaults synchronize];</span><br></pre></td></tr></table></figure><h4 id="取数据"><a href="#取数据" class="headerlink" title="取数据"></a>取数据</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取NSUserDefaults对象</span></span><br><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line"><span class="built_in">NSString</span> *userName  = [userDefaults objectForKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *userPhone  = [userDefaults objectForKey:<span class="string">@"phone"</span>];</span><br></pre></td></tr></table></figure><h4 id="判断一个数据是否存储在NSUserDefaults-中"><a href="#判断一个数据是否存储在NSUserDefaults-中" class="headerlink" title="判断一个数据是否存储在NSUserDefaults 中"></a>判断一个数据是否存储在NSUserDefaults 中</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([userDefaults objectForKey:<span class="string">@"Kite"</span>] == <span class="literal">nil</span>) &#123;</span><br><span class="line">    nslog(<span class="string">@"没有存储Kite用户这个数据"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果存储-key-相同，value-不同的数据，后面的数据会把前面的数据替换掉。"><a href="#如果存储-key-相同，value-不同的数据，后面的数据会把前面的数据替换掉。" class="headerlink" title="如果存储 key 相同，value 不同的数据，后面的数据会把前面的数据替换掉。"></a>如果存储 key 相同，value 不同的数据，后面的数据会把前面的数据替换掉。</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//执行完这行代码，文件中存储的数据就是现在的心value</span></span><br><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setObject:<span class="string">@"phone"</span> forKey:<span class="string">@"1877230212"</span>];</span><br><span class="line">[userDefaults synchronize];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NSUserDefaults对象是用来保存，恢复应用程序相关的偏好设置，配置数据等等。默认系统允许应用程序自定义它的行为去迎合用户的喜好。你可以在程序运行的时候从用户默认的数据库中读取程序的设置。同时NSUserDefaults的缓存避免了在每次读取数据时候都打开用户默认数据库的操作。可以通过调用synchronize方法来使内存中的缓存与用户默认系统进行同步。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yikeshu.info/categories/iOS/"/>
    
    
      <category term="OC" scheme="http://yikeshu.info/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>CollectionView 拖拽移动</title>
    <link href="http://yikeshu.info/2017/02/18/CollectionView_dragMove/"/>
    <id>http://yikeshu.info/2017/02/18/CollectionView_dragMove/</id>
    <published>2017-02-18T09:54:30.000Z</published>
    <updated>2018-01-17T03:55:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="iOS9新特性，collectionView的退拽"><a href="#iOS9新特性，collectionView的退拽" class="headerlink" title="iOS9新特性，collectionView的退拽"></a>iOS9新特性，collectionView的退拽</h4><ul><li>创建collectionView，实现代理方法和Datasource，向collectionView 添加长按事件，如下这是我创建collectionView，注册的cell。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UICollectionView</span> *)collectionView &#123;</span><br><span class="line"><span class="keyword">if</span>(_collectionView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">UICollectionViewFlowLayout</span> *flowLayout = [[<span class="built_in">UICollectionViewFlowLayout</span> alloc] init];</span><br><span class="line">        flowLayout.itemSize = <span class="built_in">CGSizeMake</span>(<span class="number">45</span>, <span class="number">45</span>);</span><br><span class="line">        flowLayout.minimumLineSpacing = <span class="number">10</span>;</span><br><span class="line">        flowLayout.minimumInteritemSpacing = <span class="number">10</span>;</span><br><span class="line">        flowLayout.sectionInset = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">        _collectionView = [[<span class="built_in">UICollectionView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, KScreenWidth, KScreenHeight) collectionViewLayout:flowLayout];</span><br><span class="line">        _collectionView.delegate = <span class="keyword">self</span>;</span><br><span class="line">        _collectionView.dataSource = <span class="keyword">self</span>;</span><br><span class="line">        _collectionView.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        [_collectionView registerClass:[MoveCollectionViewCell <span class="keyword">class</span>] forCellWithReuseIdentifier:identity];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UILongPressGestureRecognizer</span> *longPressGesture = [[<span class="built_in">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(longPressAction:)];</span><br><span class="line">        [_collectionView addGestureRecognizer:longPressGesture];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> _collectionView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>实现datasource ，加入数据源，</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView numberOfItemsInSection:(<span class="built_in">NSInteger</span>)section &#123;</span><br><span class="line">    <span class="keyword">return</span> _data.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    MoveCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:identity forIndexPath:indexPath];</span><br><span class="line">    cell.img = _data[indexPath.row];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>下面使用iOS9的新特性实现拖拽，必须实现下面的方法</p></li><li><p>开始移动的时候调用此方法，可以获取相应的datasource方法设置特殊的indexpath 能否移动,如果能移动返回的是YES ,不能移动返回的是NO</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)beginInteractiveMovementForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br></pre></td></tr></table></figure><ul><li>更新移动过程的位置</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateInteractiveMovementTargetPosition:(<span class="built_in">CGPoint</span>)targetPosition</span><br></pre></td></tr></table></figure><ul><li>结束移动的时候调用此方法，collectionView 会响应相应的datasource方法，collectionView:moveItemAtIndexPath:toIndexPath:  我们可以在这个方法中将移动的数据源，与目标数据源交互位置。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)endInteractiveMovement</span><br></pre></td></tr></table></figure><ul><li>取消移动的时候调用，会返回最原始的位置。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cancelInteractiveMovement;</span><br></pre></td></tr></table></figure><ul><li>在开始移动的时候会调用这个方法，如果有特殊的单元格不想被移动可以return NO， 如果没有限制就返回YES 吧。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView canMoveItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明            </th></tr></thead><tbody><tr><td style="text-align:left">collectionView</td><td style="text-align:left">调用这个代理方法的 collection View</td></tr><tr><td style="text-align:left">indexPath</td><td style="text-align:left">collectionView 中想要移动的 indexpath</td></tr></tbody></table><ul><li>移动结束的时候会调用此datasource，想要拖拽完成之后数据正确必须实现此方法，使用新的路径更新数据源，如果不实现此方法，刚刚移动cell中的数据不会重新排列。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView moveItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)sourceIndexPath</span><br><span class="line">           toIndexPath:(<span class="built_in">NSIndexPath</span> *)destinationIndexPath</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明            </th></tr></thead><tbody><tr><td style="text-align:left">collectionView</td><td style="text-align:left">正在响应这个方法的collectionView</td></tr><tr><td style="text-align:left">sourceIndexPath</td><td style="text-align:left">原始移动的indexpath</td></tr><tr><td style="text-align:left">destinationIndexPath</td><td style="text-align:left">移动到目标位置的indexpath</td></tr></tbody></table><ul><li>刚刚我们已经给collectionView 添加了长按的手势，目的就是长按的时候，可以拖动cell来进行移动，那怎么开始移动呢？我们来实现长按事件看看。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)longPressAction:(<span class="built_in">UILongPressGestureRecognizer</span> *)longPress &#123;</span><br><span class="line">    <span class="comment">//获取此次点击的坐标，根据坐标获取cell对应的indexPath</span></span><br><span class="line">    <span class="built_in">CGPoint</span> point = [longPress locationInView:_collectionView];</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span>.collectionView indexPathForItemAtPoint:point];</span><br><span class="line">    <span class="comment">//根据长按手势的状态进行处理。</span></span><br><span class="line">    <span class="keyword">switch</span> (longPress.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>:</span><br><span class="line">            <span class="comment">//当没有点击到cell的时候不进行处理</span></span><br><span class="line">            <span class="keyword">if</span> (!indexPath) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始移动</span></span><br><span class="line">            [_collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>:</span><br><span class="line">        <span class="comment">//移动过程中更新位置坐标</span></span><br><span class="line">            [_collectionView updateInteractiveMovementTargetPosition:point];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:</span><br><span class="line">        <span class="comment">//停止移动调用此方法</span></span><br><span class="line">            [_collectionView endInteractiveMovement];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//取消移动</span></span><br><span class="line">            [_collectionView cancelInteractiveMovement];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面这两个方法都需要实现。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在开始移动时会调用此代理方法，</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView canMoveItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">//根据indexpath判断单元格是否可以移动，如果都可以移动，直接就返回YES ,不能移动的返回NO</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在移动结束的时候调用此代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView moveItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)sourceIndexPath toIndexPath:(<span class="built_in">NSIndexPath</span>*)destinationIndexPath &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *sourceIndexPath 原始数据 indexpath</span></span><br><span class="line"><span class="comment">     * destinationIndexPath 移动到目标数据的 indexPath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    [_data removeObjectAtIndex:sourceIndexPath.row];</span><br><span class="line">    <span class="built_in">UIImage</span> *img = _data[sourceIndexPath.row]</span><br><span class="line">    [_data insertObject:img atIndex:destinationIndexPath.row];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="自己写collectionView拖拽的方法"><a href="#自己写collectionView拖拽的方法" class="headerlink" title="自己写collectionView拖拽的方法"></a>自己写collectionView拖拽的方法</h4><ul><li><p>如果你的手机支持iOS9或更高版本，使用苹果为我们提供的方法实现拖拽功能是没有问题的。相信还有很多都在支持ios8，所以下面的方法也许很适用。</p><ul><li><p>在<strong>- (UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</strong> 方法中，为每个cell添加长按手势，这样就可以在你长按cell的时候响应事件。</p></li><li><p>下面我们看看长按事件中应该实现怎样的方法。</p></li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)longPressAction:(<span class="built_in">UILongPressGestureRecognizer</span> *)longPress &#123;</span><br><span class="line">   <span class="comment">//获取当前cell所对应的indexpath </span></span><br><span class="line">   MoveCollectionViewCell *cell = (MoveCollectionViewCell *)longPress.view;</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *cellIndexpath = [_collectionView indexPathForCell:cell];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将此cell 移动到视图的前面</span></span><br><span class="line">    [_collectionView bringSubviewToFront:cell];</span><br><span class="line">    _isChange = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (longPress.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>: &#123;</span><br><span class="line">        <span class="comment">//使用数组将collectionView每个cell的 UICollectionViewLayoutAttributes 存储起来。</span></span><br><span class="line">            [<span class="keyword">self</span>.cellAttributesArray removeAllObjects];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.data.count; i++) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.cellAttributesArray addObject:[_collectionView layoutAttributesForItemAtIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForRow:i inSection:<span class="number">0</span>]]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>: &#123;</span><br><span class="line">            <span class="comment">//在移动过程中，使cell的中心与移动的位置相同。</span></span><br><span class="line">            cell.center = [longPress locationInView:_collectionView];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">UICollectionViewLayoutAttributes</span> *attributes <span class="keyword">in</span> <span class="keyword">self</span>.cellAttributesArray) &#123;</span><br><span class="line">            <span class="comment">//判断移动cell的indexpath，是否和目的位置相同，如果相同isChange为YES,然后将数据源交换</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(attributes.frame, cell.center) &amp;&amp; cellIndexpath != attributes.indexPath) &#123;</span><br><span class="line">                    _isChange = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="built_in">NSString</span> *imgStr = <span class="keyword">self</span>.data[cellIndexpath.row];</span><br><span class="line">                    [<span class="keyword">self</span>.data removeObjectAtIndex:cellIndexpath.row];</span><br><span class="line">                    [<span class="keyword">self</span>.data insertObject:imgStr atIndex:attributes.indexPath.row];</span><br><span class="line">                    [<span class="keyword">self</span>.collectionView moveItemAtIndexPath:cellIndexpath toIndexPath:attributes.indexPath];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>: &#123;</span><br><span class="line">            <span class="comment">//如果没有改变，直接返回原始位置</span></span><br><span class="line">            <span class="keyword">if</span> (!_isChange) &#123;</span><br><span class="line">                cell.center = [_collectionView layoutAttributesForItemAtIndexPath:cellIndexpath].center;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 不使用iOS9的代理方法，实现拖拽移动也很简单,可以试试。<br> 代码已经放到github仓库请点击这里 <strong><a href="https://github.com/oneMoreTime1357/CollectionViewTips" target="_blank" rel="noopener">项目链接</a></strong> 查看</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;iOS9新特性，collectionView的退拽&quot;&gt;&lt;a href=&quot;#iOS9新特性，collectionView的退拽&quot; class=&quot;headerlink&quot; title=&quot;iOS9新特性，collectionView的退拽&quot;&gt;&lt;/a&gt;iOS9新特性，collectionView的退拽&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;创建collectionView，实现代理方法和Datasource，向collectionView 添加长按事件，如下这是我创建collectionView，注册的cell。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UICollectionView&lt;/span&gt; *)collectionView &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(_collectionView == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;UICollectionViewFlowLayout&lt;/span&gt; *flowLayout = [[&lt;span class=&quot;built_in&quot;&gt;UICollectionViewFlowLayout&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        flowLayout.itemSize = &lt;span class=&quot;built_in&quot;&gt;CGSizeMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;45&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;45&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        flowLayout.minimumLineSpacing = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        flowLayout.minimumInteritemSpacing = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        flowLayout.sectionInset = &lt;span class=&quot;built_in&quot;&gt;UIEdgeInsetsMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _collectionView = [[&lt;span class=&quot;built_in&quot;&gt;UICollectionView&lt;/span&gt; alloc] initWithFrame:&lt;span class=&quot;built_in&quot;&gt;CGRectMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, KScreenWidth, KScreenHeight) collectionViewLayout:flowLayout];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _collectionView.delegate = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _collectionView.dataSource = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _collectionView.backgroundColor = [&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; whiteColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_collectionView registerClass:[MoveCollectionViewCell &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;] forCellWithReuseIdentifier:identity];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;UILongPressGestureRecognizer&lt;/span&gt; *longPressGesture = [[&lt;span class=&quot;built_in&quot;&gt;UILongPressGestureRecognizer&lt;/span&gt; alloc] initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; action:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(longPressAction:)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_collectionView addGestureRecognizer:longPressGesture];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _collectionView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yikeshu.info/categories/iOS/"/>
    
    
      <category term="OC" scheme="http://yikeshu.info/tags/OC/"/>
    
  </entry>
  
</feed>
