<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MissYang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yikeshu.info/"/>
  <updated>2017-08-11T12:36:48.000Z</updated>
  <id>http://yikeshu.info/</id>
  
  <author>
    <name>杨小丹</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解JavaScript中的闭包</title>
    <link href="http://yikeshu.info/2017/08/11/%5B%E8%AF%91%5D%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <id>http://yikeshu.info/2017/08/11/[译]理解JavaScript中的闭包/</id>
    <published>2017-08-11T12:27:57.000Z</published>
    <updated>2017-08-11T12:36:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>闭包并不复杂。学习和理解闭包的基础知识仅仅只需要10分钟。</p><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>闭包是JavaScript的一部分，每个工程师都应该知道和理解闭包。今天的文章只是撇开闭包的表面，但是将会给你一个很好的思想，关于什么是闭包和它在JavaScript中是如何运行的。好了，接下来我们开始吧。</p><p>我们先从书本中闭包的定义开始。</p><h4 id="定义1"><a href="#定义1" class="headerlink" title="定义1"></a>定义1</h4><blockquote><p>闭包是一个能访问父作用域的函数，即使此作用域关闭了。</p></blockquote><h4 id="定义2"><a href="#定义2" class="headerlink" title="定义2"></a>定义2</h4><blockquote><p>闭包是一个函数和该函数被声明的词汇环境的组合。</p></blockquote><p>很好，但是这些真正的意思是什么？<br><a id="more"></a><br>首先你需要理解在JavaScript中的<strong>作用域</strong>，作用域实质上是变量在JavaScript中的生命周期。因此，当一个变量定义了一个大的作用域，这个变量会存活多久，那个方法在你的程序中会访问到它。</p><p>让我们看一个例子。</p><p>当你在JavaScript中创建一个函数，它可以访问创建在这个函数里面和外面的变量。</p><p>变量创建在一个函数中也定义了这个变量。一个局部变量只能在这个被定义的函数里面访问到。在下面这个例子中，你将会看到如果我们尝试在这个函数外面打印<code>words</code>，它会输出错误信息。这是因为<code>words</code>是一个内部作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak () &#123;</span><br><span class="line">  var words = &apos;hi&apos;;</span><br><span class="line">  console.log(words);</span><br><span class="line">&#125;</span><br><span class="line">speak(); // hi</span><br><span class="line">console.log(words); // undefined</span><br></pre></td></tr></table></figure><p>和上一个例子不同，这次我们定义这个words 为全局作用域。<br>意思是说我们可以在任何函数中访问这个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 将变量放到函数的外面</span><br><span class="line">// words 现在是个全局变量</span><br><span class="line">var words = &apos;hi&apos;;</span><br><span class="line">function speak()&#123; </span><br><span class="line">  console.log(words);</span><br><span class="line">&#125;</span><br><span class="line">speak(); // &apos;hi&apos; </span><br><span class="line">console.log(words); // &apos;hi&apos;</span><br></pre></td></tr></table></figure><h4 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h4><p>我们将一个函数放到另一个函数里面会发生什么？我想你跟着操作下面的例子，因为这个会很有趣！</p><p>如果你使用谷歌浏览器，打开你的开发工具调试模式：<br>[Windows]：Ctrl + Shift + J<br>[MAC]：Cmd + Opt + J</p><p>Cool，现在拷贝下面的代码然后粘贴到你的控制台中。我们现在做的是创建一个名字为<code>speak</code>的函数。<code>speak</code>返回一个名称为<code>logIt</code>的函数。最终<code>logIt</code>在控制台中打印log值为<code>words</code>，在这个实例要实现在控制台中输出 <code>‘hi’</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">  return function logIt() &#123;</span><br><span class="line">    var words = &apos;hi&apos;;</span><br><span class="line">    console.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你拷贝到这段代码到你的控制台中，我们将要创建一个变量，然后将speak函数赋值给它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sayHello = speak();</span><br></pre></td></tr></table></figure></p><p>现在我们可以看见这个变量<code>sayHello</code> 调用了之后，没有执行内部函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sayHello;</span><br><span class="line">//  function logIt() &#123;</span><br><span class="line">//    var words = &apos;hi&apos;;</span><br><span class="line">//    console.log(words);</span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure></p><p>如上打印的结果，<code>sayHello</code> 打印的是我们return的内部函数，也就是说，如果我们执行<code>sayHello()</code>在控制台中，它将会唤起执行<code>logIt()</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sayHello();</span><br><span class="line">// &apos;hi&apos;</span><br></pre></td></tr></table></figure></p><p>它奏效了，但是并没有任何特别。让我们移除一行代码看看什么发生了改变。请看下面的示例。我们将清楚定义的变量<code>words</code>移到<code>speak()</code>函数的里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">  var words = &apos;hi&apos;;</span><br><span class="line">  return function logIt() &#123;</span><br><span class="line">    console.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像之前的操作，让我们定义一个变量并将speak函数赋值给它:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sayHello = speak();</span><br></pre></td></tr></table></figure></p><p>现在我们看看我们的 sayHello变量会输出什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHello</span><br><span class="line">//  function logIt() &#123;</span><br><span class="line">//    console.log(words);</span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure></p><p>哦，这里没有<code>words</code> 变量的定义，那么发生了什么当我们执行这个函数的时候？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sayHello();</span><br><span class="line">// &apos;hi&apos;</span><br></pre></td></tr></table></figure></p><p>它仍然起作用了！这是因为你刚刚体验了闭包的影响。</p><p>是否有点疑惑？没关系，回想下我们的闭包的定义：</p><blockquote><p>闭包是一个能访问父作用域的函数，即使此作用域关闭了。</p></blockquote><p>在这个例子中我们的<code>speak()</code>函数作用域关闭了。这意味着 <code>var words = &#39;hi&#39;</code> 应该消失了。然而，在JS中我们有一个名称将这种现象叫做闭包：<strong><em>我们的内部函数保持对其创建的范围的引用</em></strong>。这就允许<code>logIt()</code>函数仍然可以访问<code>words</code>这个变量——即使<code>speak()</code>这个函数作用域关闭了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">  var words = &apos;hi&apos;;</span><br><span class="line">  return function logIt() &#123;</span><br><span class="line">    console.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>重要提示，在JavaScript中每个函数都有一个闭包。你不需要你去解释闭包在函数中是怎么运行的，它仅仅只是JavaScript的一部分。</p></blockquote><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p>让我们查看另一个例子。这个例子有点复杂，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function name(n) &#123;</span><br><span class="line">  return function(a) &#123;</span><br><span class="line">    return `$&#123;n&#125; likes $&#123;a&#125;`;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们定义了一个名字为<code>name</code> 的函数可以传递一个参数，返回一个匿名函数，可以传递一个不同的参数，内部函数返回一个字符串。</p><p>我们用<code>name</code>函数创建两个变量。一个我们给name函数传递 John，另一个传 Cindy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var j = name(&apos;John&apos;);</span><br><span class="line">var c = name(&apos;Cindy&apos;);</span><br></pre></td></tr></table></figure></p><p>让我们看看<code>j</code>现在能打印什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j;</span><br><span class="line">//  function (a) &#123;</span><br><span class="line">//    return `$&#123;n&#125; likes $&#123;a&#125;`;</span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure></p><p>所以根据之前示例我们知道这是因为闭包，这个函数应该仍然可以访问<code>n</code>的变量通过父作用域。我们所能做的是把<code>a</code>传递过去，在执行函数的时候。</p><p>让我们试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j(&apos;dogs&apos;);  // &apos;John likes dogs&apos;</span><br><span class="line">c(&apos;cats&apos;);  // &apos;Cindy likes cats&apos;</span><br></pre></td></tr></table></figure></p><p>成功了！因为闭包我们才能从之前关闭的作用域引用变量成功的执行我们的函数。</p><hr><p>##总结<br>希望你现在可以理解基本的闭包在JavaScript和它是如何运行的！这虽然只是冰山一角，但明白了基础知识才能学习和练习更复杂的闭包。</p><hr><p>翻译原文链接：<a href="https://codeburst.io/understand-closures-in-javascript-d07852fa51e7" target="_blank" rel="noopener">https://codeburst.io/understand-closures-in-javascript-d07852fa51e7</a><br>翻译中有疏漏的地方，欢迎指正。</p><p>校对：蹦蹦</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包并不复杂。学习和理解闭包的基础知识仅仅只需要10分钟。&lt;/p&gt;
&lt;h2 id=&quot;什么是闭包？&quot;&gt;&lt;a href=&quot;#什么是闭包？&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包？&quot;&gt;&lt;/a&gt;什么是闭包？&lt;/h2&gt;&lt;p&gt;闭包是JavaScript的一部分，每个工程师都应该知道和理解闭包。今天的文章只是撇开闭包的表面，但是将会给你一个很好的思想，关于什么是闭包和它在JavaScript中是如何运行的。好了，接下来我们开始吧。&lt;/p&gt;
&lt;p&gt;我们先从书本中闭包的定义开始。&lt;/p&gt;
&lt;h4 id=&quot;定义1&quot;&gt;&lt;a href=&quot;#定义1&quot; class=&quot;headerlink&quot; title=&quot;定义1&quot;&gt;&lt;/a&gt;定义1&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;闭包是一个能访问父作用域的函数，即使此作用域关闭了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;定义2&quot;&gt;&lt;a href=&quot;#定义2&quot; class=&quot;headerlink&quot; title=&quot;定义2&quot;&gt;&lt;/a&gt;定义2&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;闭包是一个函数和该函数被声明的词汇环境的组合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很好，但是这些真正的意思是什么？&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yikeshu.info/categories/JS/"/>
    
    
      <category term="JS" scheme="http://yikeshu.info/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>解决Chrome不能播放mp4视频的问题和HLS视频播放</title>
    <link href="http://yikeshu.info/2017/08/11/%E8%A7%A3%E5%86%B3Chrome%E4%B8%8D%E8%83%BD%E6%92%AD%E6%94%BEmp4%E8%A7%86%E9%A2%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8CHLS%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/"/>
    <id>http://yikeshu.info/2017/08/11/解决Chrome不能播放mp4视频的问题和HLS视频播放/</id>
    <published>2017-08-11T12:25:12.000Z</published>
    <updated>2017-08-11T12:57:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在面临一个问题chrome中播放后缀名为.mp4的视频文件只有声音播放不出视频画面，上网查了一下才知道，MP4视频不是说后缀名以.mp4结尾的就是MP4视频，mp4视频还包括不同的编码格式，还有不同的扩展名，都可以统一定义成MP4文件，而chrome只支持标准的H.264方式的编码，所以如果视频编码格式不对，chrome还是加载不出来的。<br><a id="more"></a><br>想要查看视频的编码格式，最简单查看视频信息的方式是，在文件中选中视频点击右键查看简介或者详细信息，下面有一个栏信息是编解码器：标准的编码格式是H.264，如果不是这种格式，那很抱歉chrome加载不出来是正常的。</p><p>为什么chrome只支持H264这种格式呢，而不支持所有的视频编码格式？查了一下大概是说，绝大部分的视频编码格式都是要付专利费的，Google已经买了H264编码格式，所以其他的就不买了，Firefox没有Google那么有钱不愿意买。不过它使用Flash，绝大部分的视频格式基本上可以通过Flash播放。</p><p>而我司解决办法是，将MP4视频文件转码统一转成hls格式编码的视频，这种格式的视频后缀名是以.m3u8结尾的。</p><h4 id="什么是HLS？"><a href="#什么是HLS？" class="headerlink" title="什么是HLS？"></a>什么是HLS？</h4><p>HTTP Live Streaming（简称HLS）是一个基于HTTP的视频流协议，由苹果公司实现，</p><p>HTTP流媒体直播(HLS)是一种基于HTTP的媒体流媒体通信协议，由苹果公司实施，作为QuickTime、Safari、OS X和iOS软件的一部分。它的工作原理是将整个流程分解成一个小的基于http的文件下载序列，每个下载都加载了一个完整的潜在无界传输流的一小块。</p><h4 id="什么m3u8"><a href="#什么m3u8" class="headerlink" title="什么m3u8"></a>什么m3u8</h4><p>先说说M3U，M3U是一种播放多媒体列表的文件格式，它的设计初衷是为了播放音频文件比如MP3,但是越来越多的软件现在用来播放视频文件列表，M3U也是可以指定在线留媒体音频源。很多播放器和软件都支持M3U文件格式。</p><p>M3U8是Unicode版本的M3U，用UTF-8编码。’M3U’和M3U8‘文件都是苹果公司使用的HTTP Live Streaming格式的基础，这种格式可以在iPhone和Macbook等设备播放。</p><h4 id="平台支持情况"><a href="#平台支持情况" class="headerlink" title="平台支持情况"></a>平台支持情况</h4><p>苹果的产品都能很好的支持，iPhone、Safari，但是在chrome和Firefox还有一些其他未知的浏览器不支持播放这种视频格式。</p><p>So，想要播放这种格式的视频，前端这块还要做一层处理，不过不用担心，已经有人帮我们造好轮子了，Github上有很好的库可以支持这种视频格式的播放，<a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">VideoJs</a>,<a href="https://github.com/videojs/videojs-contrib-hls" target="_blank" rel="noopener">videojs-contrib-hls</a><br>集成起来也非常的简单，github上都给了一些示例。</p><h4 id="快速集成开发"><a href="#快速集成开发" class="headerlink" title="快速集成开发"></a>快速集成开发</h4><p>在<code>head</code>头中引入如下的CDN，需要引入videojs的样式，是为了使用播放器的样式，要不然播放器会很难看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;//vjs.zencdn.net/5.19/video-js.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;script src=&quot;//vjs.zencdn.net/5.19/video.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.8.3/videojs-contrib-hls.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;video id=&quot;video-play&quot; class=&quot;video-js vjs-default-skin&quot;</span><br><span class="line">      style=&quot;width: 600px; height: 400px;&quot;</span><br><span class="line">      playsinline webkit-playsinline</span><br><span class="line">      controls preload=&quot;auto&quot;</span><br><span class="line">      x-webkit-airplay=&quot;true&quot; controlsList=&quot;nodownload&quot; oncontextmenu=&quot;return false&quot;&gt;</span><br><span class="line">      &lt;source src=&quot;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt;</span><br><span class="line">    &lt;/video&gt;</span><br><span class="line">    &lt;button&gt;播放&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var el = document.getElementById(&quot;play-btn&quot;)</span><br><span class="line">    el.addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">        window.videojs(&apos;video-play&apos;, &#123;&#125;, function onPlayerReady () &#123;</span><br><span class="line">         this.play()</span><br><span class="line">         this.on(&apos;ended&apos;, function () &#123;</span><br><span class="line">             console.log(&apos;ended, video js&apos;)</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h4><ul><li>MP4视频编码格式有哪几种<br>MP4视频格式包括：MPEG-4 SP(Simple Profile/简单类)/ASP(Advanced Simple Profile/高级简单类)：xvid, divx5, 3ivx,ffmpeg/ffdshow, NeroDigital ASP…及MPEG-4 AVC/H.264：x264, NeroDigital AVC, Apple…还有MPEG-2, MPEG-1（不含Divx3/M$ MPEG4, WM9, RV9或VP6）.-</li></ul><hr><p>参考链接：<br>Mp4编码全介绍：<a href="https://my.oschina.net/alphajay/blog/4276" target="_blank" rel="noopener">https://my.oschina.net/alphajay/blog/4276</a><br><a href="http://www.jianshu.com/p/52c569efbfc0" target="_blank" rel="noopener">http://www.jianshu.com/p/52c569efbfc0</a><br><a href="https://imququ.com/post/html5-live-player-1.html" target="_blank" rel="noopener">https://imququ.com/post/html5-live-player-1.html</a><br><a href="http://yanhaijing.com/html/2016/03/12/html5-video/" target="_blank" rel="noopener">http://yanhaijing.com/html/2016/03/12/html5-video/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在面临一个问题chrome中播放后缀名为.mp4的视频文件只有声音播放不出视频画面，上网查了一下才知道，MP4视频不是说后缀名以.mp4结尾的就是MP4视频，mp4视频还包括不同的编码格式，还有不同的扩展名，都可以统一定义成MP4文件，而chrome只支持标准的H.264方式的编码，所以如果视频编码格式不对，chrome还是加载不出来的。&lt;br&gt;
    
    </summary>
    
      <category term="WEB" scheme="http://yikeshu.info/categories/WEB/"/>
    
    
  </entry>
  
  <entry>
    <title>职场主动</title>
    <link href="http://yikeshu.info/2017/07/01/jobInitiative/"/>
    <id>http://yikeshu.info/2017/07/01/jobInitiative/</id>
    <published>2017-07-01T14:24:49.000Z</published>
    <updated>2017-07-01T14:32:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近喜欢看美国的一个真人秀节目—《学徒》，《学徒》是美国全国广播公司出品的一档职场创业型真人秀节目，这档节目的制作人是纽约的地产大亨唐纳德•特朗普（DonaldTrump）也就是现在的美国总统，他从全美21万多志愿者中选择16名学徒候选人加入比赛，这些被选拔出的选手们则要为了获得特朗普旗下的一个商业项目的经营机会而展开竞争。这个节目04年的时候开始播出，第一季一播出就风靡了全美国，连续四个月位居收视冠军宝座，平均家庭收视数位2070万，最高家庭收视数达4010万，成为五年来18——49岁成年任收视率最高的节目。我也是出于对特朗普的好奇，才开始看这期节目。</p><p>这两天刚看了第二季的第一集，所有征集来的参赛者将面临第一次竞争，首先将男生和女生各分成一组，两组展开竞争，这一次稍有点不同，按照男女分好组之后，要求男生组选出一个人去当女生队的队长，女生队选出一个人去当男生队的队长，说实话选出一个人比较难，去到任何一队都会很艰难，同性别的人很好交流，首先性别相同就很容易找到共同话题，而在当时的环境下，大家相处紧紧只有几个小时，要选出一个人去当他们的队长，还要去管理他们，如果我是身处在女性团队中的一个人，我是不愿意站出来说，我去他们组，真的这很艰难。但他们但凡被挑选出来一定有很强的能力，也是一群聪明人，商讨了一下，每一队都有人主动站出来，主动去担当其他队的队长，这是一个好机会，也是一个不小的挑战，如果失败就会面临被开除的风险。<br><a id="more"></a><br>他们这次执行的任务是，在玩具公司，为他们提供各种资源，各设计一款玩具，最后由专业人士评选出谁更受欢迎，受欢迎的那组获胜。整个设计过程不再细说了，只说我印象深刻的一点，其实也是我最关注的一点就是，其中一个团队失败了，在会议室见川普的那一刻，决定开除谁的那一刻。</p><p>这一集男生队失败了，在会议室里川普问在场的队员，觉得谁做的比较差，如果开除掉一个人你会开除谁，大家说的最多的就是罗杰，觉的他没有为整个团队做多大的贡献，而问罗杰：“你为什么没有为团队贡献”，他说是因为队长没有为他分配任务。罗杰是个典型的被动型人才，如果队长没有给他分配任务，他就觉得这个事情无从下手，本来面对一个大家不熟悉的玩具行业，大家也是摸着石头过河，各尽其能，而队长其实也没有将任务分配给各个人，说你要做什么，你去做什么，大家都做什么，相处的时间很短暂，大家互相了解的都不够，作为一个管理人员，是不可能分工明细，做到每个人都分配到任务。在这种情况下，就应该更主动一点，提出自己的想法，尽自己的一份力，而不是要让别人告诉你要做什么，不要做什么。罗杰肯定是一个好员工，但他缺少主动性，总是要让别人告诉你，你要去做什么，这样就会让机会白白的溜走。最后川普终于对他说出了那句话：“You are fired!”</p><p>职场中要想提高自己，是最不能缺少主动性的场所，反思一下我在工作中也是极度缺乏主动性的一个人，在工作中比如说有什么需求，就做这个需求，做完了就完了，明知道自己写的代码还有很多优化的空间，但就是不愿意主动提出来去修改，最明显的一个例子是，现在有个需求，只是修改一个小问题，已经提出来了，我当时也没有什么要紧的事，而我的另一个同事也在忙一些手头上不紧急的事情，但总是在我犹豫要不要做接这个需求的时候，他总是很主动的说交给我吧，每当线上出现问题的时候，他总是第一个出来询问现象，找到问题然后解决掉，年纪虽然不大，初入职场不久，看这势头以后前途无量啊。现在整个团队都很信任他，我虽然工作时间比较长了，但做什么事缺乏主动性，比较犹豫，一直把自己当成一个打工仔来思考问题，组长分配你什么任务就做什么，超过自己的需求范围一概不管，我这种虽然能把手头上的事情做好，但也仅限手头上的事而已，要想有所提升，在团队中提高自己的能力和信任感，还需要更主动的多做一些事情，多承担一些责任，做的越多对业务越熟练也就能越快的解决问题。</p><p>虽然这个节目只是为了赚钱、为特朗普选拔人才，但可以看到真实的商场和职场人的真实状态，从中学习到的职场思维，和如何在一群比你更聪明的人中脱颖而出，面对机会的时候，紧紧的抓住并主动出击，机会并不会求着你让你收下它，如果不争取它就会从你身边溜走。我相对来说面对职场这种丛林法则，自己的经验还是偏少，处理不好人际关系，缺少沟通交流的经验，还停留在学生思维，有人给你留作业，就认真完成，然后交作业。但在工作中不可能事无巨细的任何事情都给你安排好了，业务很紧急任务很多的时候，没有人顾得上你，先将自己该做的事情做好，然后更主动一点，才能在职场上有所成长晋升。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近喜欢看美国的一个真人秀节目—《学徒》，《学徒》是美国全国广播公司出品的一档职场创业型真人秀节目，这档节目的制作人是纽约的地产大亨唐纳德•特朗普（DonaldTrump）也就是现在的美国总统，他从全美21万多志愿者中选择16名学徒候选人加入比赛，这些被选拔出的选手们则要为了获得特朗普旗下的一个商业项目的经营机会而展开竞争。这个节目04年的时候开始播出，第一季一播出就风靡了全美国，连续四个月位居收视冠军宝座，平均家庭收视数位2070万，最高家庭收视数达4010万，成为五年来18——49岁成年任收视率最高的节目。我也是出于对特朗普的好奇，才开始看这期节目。&lt;/p&gt;
&lt;p&gt;这两天刚看了第二季的第一集，所有征集来的参赛者将面临第一次竞争，首先将男生和女生各分成一组，两组展开竞争，这一次稍有点不同，按照男女分好组之后，要求男生组选出一个人去当女生队的队长，女生队选出一个人去当男生队的队长，说实话选出一个人比较难，去到任何一队都会很艰难，同性别的人很好交流，首先性别相同就很容易找到共同话题，而在当时的环境下，大家相处紧紧只有几个小时，要选出一个人去当他们的队长，还要去管理他们，如果我是身处在女性团队中的一个人，我是不愿意站出来说，我去他们组，真的这很艰难。但他们但凡被挑选出来一定有很强的能力，也是一群聪明人，商讨了一下，每一队都有人主动站出来，主动去担当其他队的队长，这是一个好机会，也是一个不小的挑战，如果失败就会面临被开除的风险。&lt;br&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://yikeshu.info/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>从编程中我学到了什么</title>
    <link href="http://yikeshu.info/2017/05/10/%E4%BB%8E%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%88%91%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://yikeshu.info/2017/05/10/从编程中我学到了什么/</id>
    <published>2017-05-09T23:49:52.000Z</published>
    <updated>2017-07-01T14:33:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先先介绍一下自己，我是一名程序员目前做的是前端开发的工作。本科学的是软件工程，没有脱离本专业的领域，用一句话来说就是科班出身的程序员。但我并不是什么很聪明的人，也不是从一开始就能很顺利的学好，决定以后工作就做编程这件事情。</p><p>记得刚上大一的时候，刚开始接触编程，学的第一门语言是C语言，每次上课都感觉自己像听天书一样，老师在上面讲的什么完全听不懂，当时就觉得编程好难啊，心想以后肯定不会做程序员，而且我们班的大部分女性同胞都有一个这样的认识，觉得女生不适合做程序员，总是玩命加班、熬夜了，总之印象不好，当时都认为就算现在学的是这个专业，以后还会计划着去做其他的事情，虽然当时和她们达成了共识，但我心里一直觉得编程是一件很酷的事情，而且很羡慕会编程的人，能做出自己想做的东西。就这样浑浑噩噩的过了大一，直到大二开始学习新语言JAVA，由于很喜欢教这门课的老师，老师教的也很有趣，所以也愿意跟着老师的步伐一步一步的来，从做一些简单的小demo开始，虽然刚开始还是什么都不懂，但有教程跟着一步步来，在不断调试试错之后，程序运行成功的那一刻，觉得很有意思也很有成就感，慢慢发现了编程的乐趣，自己也能写一些简单的小东西出来。当你对一个世界很好奇，而现在有人给你打开一条门缝，让你可以透过门缝窥探那个神奇的世界，你就会知道这有多兴奋，我也一直很好奇编程的世界，在大二时编程的初体验算是对我决定做一个程序员的萌芽阶段。<br><a id="more"></a><br>在做了程序员这么久，每天都坐在哪里敲代码，面对这个花花绿绿的世界我们的脑子里似乎只装了各种编程语言各种实现方法，但编程究竟为我带来了什么，我从这份职业中体会到了什么，这也是我一直在不断思考的事情。下面我想出了几点，从我的视角出发谈谈编程。</p><h4 id="编程教会了我如何面对挫折，不断的挑战自己"><a href="#编程教会了我如何面对挫折，不断的挑战自己" class="headerlink" title="编程教会了我如何面对挫折，不断的挑战自己"></a>编程教会了我如何面对挫折，不断的挑战自己</h4><p>当我们在实现一个功能的时候，从刚开始的构想到设计函数方法最后用一行行代码去实现出来，这中间的过程不可能一口气畅通无阻的写出来，而且无bug，我相信任何人都不能保证自己写出来的代码没有问题，我们总是在不断的调试不断的修改问题，尤其是做前端客户端的业务，一定要看到UI展示是否完美，数据显示是否正常，实现复杂功能的过程中，可能会遇到无数的bug，有些简单的可以很快就能解决，有些莫名其妙的bug，真的会搞到让人抓狂的地步，当绞尽脑汁想到了一种方法去解决的时候，但是又报error了，于是又去查资料寻找解决方案，就这样不断的尝试不断的试错，直至调试成功，代码运行成功的那一刻，终于长舒了一口气。在这调试的过程中，程序员每天要面对N多次的失败，每一次失败都是一次打击，但我们从来不会放弃，坚信总会有解决办法的。把在程序世界经历的失败类比到现实生活中就像挫折一样，你做某件事情也不可能一次就能成功，生活中的问题就像bug一样，也需要不断的尝试，不断的调整自己，直至解决。所以编程的每一天都在经历失败经历挫折，而编程教会了我如何面对失败如何面对挫折——要勇敢的去正视它寻找解决方法，勇于尝试，勇于挑战自己。</p><h4 id="编程教会了我如何去解决问题"><a href="#编程教会了我如何去解决问题" class="headerlink" title="编程教会了我如何去解决问题"></a>编程教会了我如何去解决问题</h4><p><strong>发现问题是解决问题的第一步</strong>，我总是这样说，其实这个信条也是我在编程中发现的。每次好不容易做好一个功能，自测也没有问题，于是开始提交测试，让测试去测测，感觉也没有什么大问题，于是开始自我放松一会。但每次测试总能找到bug，不管它隐藏的有多深，有时候看着自己代码逻辑明明是正确的，但测试测的就有问题，不修不行啊，于是带着怀疑的态度再查看了一遍代码，调试运行排查，这样来了一轮之后，有些问题就显示出来了，有些隐藏的还比较深需要进一步排查。所以一般测试发现了问题，就肯定是有问题的，还是尽快去解决要不然会引起大问题的。生活中也是这样，但没有人像测试一样，测出你的问题，而是需要自己去反思、去发现问题、去解决。就像两人相处一样，偶尔闹个矛盾，可能某个人主动承认错误哄两下就好了，好这就过去了，但这只是表面现象，没有根本上解决问题，如果这种事情出现几次，每次都这样过去了，心里的结就越堆越多，到最后某一天肯定会井喷式爆发，就崩了。就像编程中为了紧急上线赶功能，挖了一些坑在代码中，但也不影响功能，就上线了，然后就不管了，如果这样的坑越来越多，而不尝试去解决，迟早某一天会爆发的。有一句话怎么说，出来混迟早要还的。所以你挖的坑，迟早要填的。发现问题之后要去解决它而不是忽视。</p><h4 id="编程使我打破自己的思维局限，让我知道，只要你想做就可以做到"><a href="#编程使我打破自己的思维局限，让我知道，只要你想做就可以做到" class="headerlink" title="编程使我打破自己的思维局限，让我知道，只要你想做就可以做到"></a>编程使我打破自己的思维局限，让我知道，只要你想做就可以做到</h4><p>以前总是怀疑自己，编程到底适不适合女生，我有时候也会被这些言论困扰，在大学的时候听的比较多，女生适合做设计，测试啊，不适合编程啊，编程很累经常加班、掉头发、死的早等等，而且身边的人都总是在说，女生适合做测试啊，设计啊或者做其他工作，编程很累的还是不要做了。在你没有成为一个程序员之前，你可能会认为这就是真的，因为所有人都这么说，而这样的认识就会让一部分人望而却步，所以会减少一部分人。就算刚开始好奇想要去尝试学习一下，但在编程过程中又会遇到各种各样的问题，有的是很顽固的bug解决不出来，始终调试不好就会对自身产生怀疑，对初学者来说就会丧失信心，如果是个女生可能会有这样的想法，编程果然不适合我啊，太难了，我还是以后转做其他的工作吧，于是又少了一部分人。这样的声音很多，或多或少对我们自身的选择也会有影响，想象一下如果我们的世界不因为你的性别而限制你的选择那该有多好，男人也可以选择在家带孩子，女人也可以选择更有挑战性的工作，大家活的都自在一点，做自己想做的事情，当然我们的社会也在慢慢变好，女程序员也变的不那么罕见。虽然我现在是一名程序员，但走到现在也有我的幸运成分，也离不开我的努力，有一句话怎么说，<strong>越努力越幸运</strong>。我其实并不聪明，学起东西来总是比别人慢半拍，对程序的领悟能力也比较差，所以对待一个问题总是要花更多的时间，而我只是比别人多花了一点时间学习。有些人问我你做程序员逻辑思维能力是不是很强，说实话如果你想做一个程序员刚开始并不需要很强的逻辑思维能力，就像大多数普通人一样就可以了，我相信随着学习的深入这种思考代码的逻辑能力会慢慢被锻炼的越来越好。而且在我真正成为一个合格的程序员之后，我认识到一个事实，像上面提到的一些对程序员的印象大部分都不是真的，不过经常加班是事实，但在大部分公司都是项目紧张的时候加班，再说不管你做什么工作，在任务紧张正常工作时间没法做完，又不得不赶进度的时候，都会选择加班来完成，所以加班不是程序员的专属名词，只不过在某些公司程序员加班比较凶猛，才让社会那么关注，但也只是存在管理流程不好的小公司，而且在公司起步阶段大家共同努力奋斗这种经历也是很宝贵的。再说说身体健康，有人说程序员每天都要做在哪里对着电脑敲代码，对身体很不好容易死的早，但纵观所有的职业那个工作不是用电脑操作的呢，当然除了一些依靠体力劳动的工作，其实我想说，选择健康是一种生活方式，不管做什么工作，身体是革命的本钱，如果你一直消耗而不积攒本钱，迟早有一天会垮的。而健康的生活只需要合理的饮食加上适当的锻炼就OK了，所以这并不是说做程序员就不健康了，程序员也可以很健康只要做到这两点合理饮食+适当的锻炼，这并不难，每个人都可以做到，你也可以做到只要你想变的更健康。关于女生适合做什么职业适不适合做程序员？没有适不适合只有想不想，如果你想做觉得编程很有意思，那就去做吧，努力学习到最后能胜任字几点工作。如果有人说你还是去做一名程序员鼓励师吧，对他笑笑就OK了，像这些怀疑你的声音是消除不掉的，我们很难去改变别人，只有用自己的行动做好自己的事情，去做自己想做的事情，何必管这些限制我们自身职业发展的思维局限。有些事情只有自己尝试了，才知道是怎么回事，就像一个冰激凌别人告诉你非常好吃、特别好吃，但你没吃到所以你根本不知道是什么味道，你也体会不到别人吃到的味道到底有多好吃。所以想做什么就去做，不要让一些思维局限住你，让别人告诉你该做什么适合做什么，适不适合只有自己知道，只有真正去尝试去努力的做了才知道。</p><p>作为公司里唯一一个女程序员，我并没有觉得很特别，我只知道编程是我的工作，而且做现在这样一份工作我很开心，尤其是和现在这群志趣相投的同事一起工作，我觉得很幸运，想要留住这份幸运就要越努力的工作。看~程序员就是需要不断的学习学习再学习，但现在这个时代，是高速发展的时代，每个人都需要不断学习才不至于与时代脱节，程序员其实也没有什么特别的，而且我相信以后编程会越来越普通，越来越成为每个人多少都会的技能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先先介绍一下自己，我是一名程序员目前做的是前端开发的工作。本科学的是软件工程，没有脱离本专业的领域，用一句话来说就是科班出身的程序员。但我并不是什么很聪明的人，也不是从一开始就能很顺利的学好，决定以后工作就做编程这件事情。&lt;/p&gt;
&lt;p&gt;记得刚上大一的时候，刚开始接触编程，学的第一门语言是C语言，每次上课都感觉自己像听天书一样，老师在上面讲的什么完全听不懂，当时就觉得编程好难啊，心想以后肯定不会做程序员，而且我们班的大部分女性同胞都有一个这样的认识，觉得女生不适合做程序员，总是玩命加班、熬夜了，总之印象不好，当时都认为就算现在学的是这个专业，以后还会计划着去做其他的事情，虽然当时和她们达成了共识，但我心里一直觉得编程是一件很酷的事情，而且很羡慕会编程的人，能做出自己想做的东西。就这样浑浑噩噩的过了大一，直到大二开始学习新语言JAVA，由于很喜欢教这门课的老师，老师教的也很有趣，所以也愿意跟着老师的步伐一步一步的来，从做一些简单的小demo开始，虽然刚开始还是什么都不懂，但有教程跟着一步步来，在不断调试试错之后，程序运行成功的那一刻，觉得很有意思也很有成就感，慢慢发现了编程的乐趣，自己也能写一些简单的小东西出来。当你对一个世界很好奇，而现在有人给你打开一条门缝，让你可以透过门缝窥探那个神奇的世界，你就会知道这有多兴奋，我也一直很好奇编程的世界，在大二时编程的初体验算是对我决定做一个程序员的萌芽阶段。&lt;br&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://yikeshu.info/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>小白健身第一周</title>
    <link href="http://yikeshu.info/2017/03/05/%E5%B0%8F%E7%99%BD%E5%81%A5%E8%BA%AB%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
    <id>http://yikeshu.info/2017/03/05/小白健身第一周/</id>
    <published>2017-03-05T10:49:31.000Z</published>
    <updated>2017-03-05T10:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>三月不减肥，五月徒伤悲。夏天来了，开始甩掉身上多余的赘肉，减肥！减肥！。正好附近有个健身房，办了张健身卡开始我的健身甩脂运动吧！</p><h4 id="制定健身计划"><a href="#制定健身计划" class="headerlink" title="制定健身计划"></a>制定健身计划</h4><p>对于小白的我第一次去健身房看到那么多器械完全是一脸懵逼的状态，到底要从哪里开始呢，这个器械要怎么操作锻炼的部位是哪里呢，完全一脸懵逼什么都不懂。没办法没钱请私教只能自己从网上找资料做笔记，根据自己的时间来安排制定健身计划。keep上有一个健身房入门女生版，看了几遍视频决定就先从这些简单的固定器械开始练习吧。<br><a id="more"></a><br>一周七天计划最少最少要去锻炼三次，本来计划是一三五、六日再去一天，这样就能有四天的锻炼时间，但是星期一第一天就没有实现。星期一按照平常的下班时间是六点四十左右，这样我到家的时间就是7点左右，这时再去健身房还不算太晚，然后再锻炼一个半小时大概八点半，就可以回家了。但没想到的是忘记考虑加班了，那天一直到加到七点多才下班，然后匆匆忙忙的找小黄车，找到好几个都是坏的没法骑了，我只好快步走回去了，到家大概7点四十左右，瞬间不想去健身房了，头也很痛。在多次斗争过后，还是懒癌细胞胜利了，放弃了去健身房，决定在家跳会HIIT，这也算运动了。最后计划调整为每周二四六必须去不得有任何的商量。周二依然加班到七点才走，但不能给自己任何的狡辩了，就算八九点了也要去健身房锻炼，不管锻炼了多久只要去了就可以，先养成去健身房锻炼身体的习惯，不能让自己那么胆怯害怕去健身房。</p><h4 id="健身房锻炼的体验"><a href="#健身房锻炼的体验" class="headerlink" title="健身房锻炼的体验"></a>健身房锻炼的体验</h4><p>总的来说，每次决定去的时候很纠结很艰难，像两方军队在打仗谁胜利了就听谁的。后来我不想思考到底是去还是不去了，既然计划了时间和地点只管换上运动鞋运动服去就好了，不要多想。这个星期还是按照自己原先调整规划好的时间去的，周二周四周六这三天，第一次只骑了20分钟的单车，第二次玩了几个简单的器械锻炼腿部的背部胸部之后再跑了30分钟，整个流程走下来已经很累了。刚开始主要是适应性训练，熟悉器械和健身房周围的环境，我不想刚开始就让自己以后再也不想去了。周六晚上去的时候人很少正好前两天一起聊天的一个教练有空，他看见我在练说要指导指导我的动作，就这样练了几组加了重量，这次练的时候比前两次都重，所以练的时候更吃力，还经过了专业的指导，动作也标准了些，所以练的更到位，身体并没有不适的感觉反而更舒服了，然后去做了半个小时的有氧运动，最后拉伸身体，锻炼完成，这个星期的任务就结束了。这三次的锻炼一次比一次的训练增强，我的运动能力也慢慢的提高了，身体好像被唤醒了一样，以前总是感觉昏昏沉沉的做什么都没有精神，自从开始锻炼以后整个人都发生了变化，精力更充沛了，也没有那种总睡不够的感觉了。工作也能更好的应对，虽然每次只花了一个半小时的时间，但我个人的精神状态，做事的效率都更好的提高了。每次锻炼完成之后虽然很累，但心情是愉悦的，也能体会到运动的乐趣。为了更美好的自己，加油加油！</p><h4 id="这几天的心得"><a href="#这几天的心得" class="headerlink" title="这几天的心得"></a>这几天的心得</h4><ul><li><p>记住当你计划好做一件事情的时候，不可能永远那么顺利，总会有突发状况等着你，延误了执行的时间，但不要心烦意乱，重要的是能在突发状况下依然坚持去执行。</p></li><li><p>不是说办了张健身卡身上的肉就能自然而然的掉下去，还要自己主动的去健身房锻炼，利用哪里的设备科学的锻炼自己的身体。没钱请私教就从网上学习，也要根据自己的身体条件选择合适的锻炼方式。好的身材都是靠练出来的，不断的锻炼才能达到目标。</p></li><li><p>我知道坚持锻炼很难，但当你把时间地点都想好以后，只管按照计划做就好了，什么都不要多想。像我计划下班之前在公司喝一杯酸奶或者一杯燕麦，这样晚餐解决了，下班回到家之后换好运动服直接去健身房，去到之后先热身然后练器械做几组，之后做有氧40分钟。这是我的计划，在脑海中模拟了几遍情景，每次时间到了潜意识就会知道该做什么了，直接做就好了不要多想。</p></li></ul><p>加油！科学的锻炼方法加上健康的饮食，就算达不到火辣的身材，也能收获健康的身体。健身第一周，感觉还不错，不得不鼓励鼓励自己做的很好，Good Job！O(∩_∩)O哈哈~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三月不减肥，五月徒伤悲。夏天来了，开始甩掉身上多余的赘肉，减肥！减肥！。正好附近有个健身房，办了张健身卡开始我的健身甩脂运动吧！&lt;/p&gt;
&lt;h4 id=&quot;制定健身计划&quot;&gt;&lt;a href=&quot;#制定健身计划&quot; class=&quot;headerlink&quot; title=&quot;制定健身计划&quot;&gt;&lt;/a&gt;制定健身计划&lt;/h4&gt;&lt;p&gt;对于小白的我第一次去健身房看到那么多器械完全是一脸懵逼的状态，到底要从哪里开始呢，这个器械要怎么操作锻炼的部位是哪里呢，完全一脸懵逼什么都不懂。没办法没钱请私教只能自己从网上找资料做笔记，根据自己的时间来安排制定健身计划。keep上有一个健身房入门女生版，看了几遍视频决定就先从这些简单的固定器械开始练习吧。&lt;br&gt;
    
    </summary>
    
      <category term="Fitness" scheme="http://yikeshu.info/categories/Fitness/"/>
    
    
  </entry>
  
  <entry>
    <title>oneDay</title>
    <link href="http://yikeshu.info/2017/02/18/oneDay/"/>
    <id>http://yikeshu.info/2017/02/18/oneDay/</id>
    <published>2017-02-18T09:56:16.000Z</published>
    <updated>2017-02-18T09:56:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 一日就是一生<br>                 —–（日）酒井雄哉</p><p>修行的每天早上，我都穿着草鞋出去。上山10公里之后，接着走10公里较平坦的路，最后是10公里的下坡路，如此这般每天重复。结束一天的登山行程后，草鞋往往变形、穿烂，隔天得穿上新鞋才行。<br>     日复一日地不断重复。有一天，我发现草鞋就像我自己。当脱掉草鞋的那一刻，今天的自己既以告终。然后，为了明天的重生而认真反省。这么一来，便能获得新生，重新出发。今天的自己，今天就结束，明天将诞生一个全新的自己。<br>     一日就是一生。</p></blockquote><p>  对于我们普通人来说，今天或许和昨天没有什么不同，每一天都在重复昨天做过的事情，生活对我们大多数人来说就是不断的重复昨天。有时会疲倦，有时也会茫然，但生活还得继续，不会因为你的小情绪，而迁就着你。身边的环境是不会改变的，唯一能改变的就是自己，努力去发现生活中的美，时刻反省自身，不断提醒自己过去的已经过去，每一日都是一个全新的自己，当你用全新的眼光观察世界，会发现每一天，每一个人都不同。五月来了，今天早上去上班意外的发现小区栅栏上的蔷薇开了，黄色的，红色的，粉色的，甚是好看，才发现每天匆匆忙忙的脚步一直往前走，竟然错过了这份美景，错过了一份好心情(<em>^__^</em>) </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 一日就是一生&lt;br&gt;                 —–（日）酒井雄哉&lt;/p&gt;
&lt;p&gt;修行的每天早上，我都穿着草鞋出去。上山10公里之后，接着走10公里较平坦的路，最后是10公里的下坡路，如此这般每天重复。结束一天的登山行程后，草鞋往往变形、穿
      
    
    </summary>
    
      <category term="Thinking" scheme="http://yikeshu.info/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>三体读书笔记</title>
    <link href="http://yikeshu.info/2017/02/18/%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yikeshu.info/2017/02/18/三体读书笔记/</id>
    <published>2017-02-18T09:56:03.000Z</published>
    <updated>2017-02-18T09:56:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从买了kindle 读的第一本书就是三体，身边好多人都说很好看，由于很好奇想看看它到底有多好看，结果一看就无法自拔，被它深深的吸引。由于平常上班还有别的事情要做，唯一能够支配的时间就是上下班路上了，每天只能在地铁上看一会，一直看了一个多月吧，才把三部看完。这个故事很长，但真的很精彩.</p><p>故事从我们现在的生活开始，到发现外星文明的入侵，人类如何应对，再到整个宇宙。仿佛就是我们身边发生的事情，距离我们并不遥远。第一步中出现的三体游戏，必须穿上V装备才能玩，V装具可以模拟游戏场景中的环境，比如在游戏中是很热的天气，你也可以感受到热量，如果很冷你也能感受到很冷，确实是一个很棒的体验，我们现在也有VR技术，只能通过带上眼镜才能看到虚拟场景，还处于初步阶段，没准以后技术成熟，也会开发出三体小说中的V装具，更真实的体验游戏世界。<br><a id="more"></a></p><p>书中好多地方的论证都是基于现在的物理基础知识，电磁波，引力波，天体物理知识运用的轻车熟路，不得不佩服作者知识的广度和深度，如果说是什么影响我让我对天文感兴趣的，那一定非《三体》这部作品莫属了。当我们仰望星空，是不是在另一个世界，另一个宇宙中也有生命活动的物体做着同样的事情。我相信有外星人的存在，宇宙这么大，而我们身处的太阳系只是冰山一角，放眼到整个宇宙只是一颗普通的星星，在茫茫宇宙之中一定有一个星球也适合生命生存，可能离我们很遥远，但我们并不孤单。</p><blockquote><p>那你的生活是一种偶然，世界有这么多变幻莫测的因素，你的人生却没什么变故。</p></blockquote><p>这个世界每一天都有那么多变化莫测的因素，如果一个人的一生都没有什么变故，确实是一种偶然</p><blockquote><p>也许，人类和邪恶的关系，就是大洋与漂浮与其上的冰山的关系，它们其实是同一种物质组成的巨大水体，冰山之所以被醒目地认出来，只是由于其形态不同而已，而它实质上只不过是这整个巨大水体中极小的一部分…人类真正的道德自觉是不可能的，就像他们不可能拔着自己的头发离开大地。要做到这一点，只有借助人类之外的力量。</p></blockquote><p>这是故事的主人公叶文洁，对人类彻底失望后，想借助外星文明，三体世界来改造这个让她失望的世界。</p><blockquote><p>这想法让我的后半辈子有一种很矛盾的心态：有时觉得生命珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值一提。反正日子就在这种奇怪的感觉中一天天过去，不知不觉就老了….</p></blockquote><p>人真的很渺小</p><blockquote><p>大部分人的爱情对象也只是存在于自己的想象之中。他们所爱的并不是现实中的他（她），而只是想象中的他（她），现实中的他（她）只是他们创造梦中情人的一个模板，他们迟早会发现梦中情人与模板之间的差异，如果适应这种差异他们就会走到一起，无法适应就分开，就这么简单。你与大多数人的区别在于：你不需要模板。</p></blockquote><p>大部分的爱情只是存在于自己的想象之中，很有道理</p><blockquote><p>文明像一场五千年的狂奔，不断的进步推动着更快的进步，无数的奇迹催生出更大的奇迹，人类似乎拥有了神一般的力量…但最后发现，真正的力量在时间手里，留下脚印比创造世界更难，在这文明的尽头，他们也只能做远古的婴儿时代做过的事情。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从买了kindle 读的第一本书就是三体，身边好多人都说很好看，由于很好奇想看看它到底有多好看，结果一看就无法自拔，被它深深的吸引。由于平常上班还有别的事情要做，唯一能够支配的时间就是上下班路上了，每天只能在地铁上看一会，一直看了一个多月吧，才把三部看完。这个故事很长，但真的很精彩.&lt;/p&gt;
&lt;p&gt;故事从我们现在的生活开始，到发现外星文明的入侵，人类如何应对，再到整个宇宙。仿佛就是我们身边发生的事情，距离我们并不遥远。第一步中出现的三体游戏，必须穿上V装备才能玩，V装具可以模拟游戏场景中的环境，比如在游戏中是很热的天气，你也可以感受到热量，如果很冷你也能感受到很冷，确实是一个很棒的体验，我们现在也有VR技术，只能通过带上眼镜才能看到虚拟场景，还处于初步阶段，没准以后技术成熟，也会开发出三体小说中的V装具，更真实的体验游戏世界。&lt;br&gt;
    
    </summary>
    
      <category term="Read" scheme="http://yikeshu.info/categories/Read/"/>
    
    
  </entry>
  
  <entry>
    <title>数据存储 NSUserDefaults</title>
    <link href="http://yikeshu.info/2017/02/18/nsuserdefaults/"/>
    <id>http://yikeshu.info/2017/02/18/nsuserdefaults/</id>
    <published>2017-02-18T09:55:09.000Z</published>
    <updated>2017-02-18T09:55:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h2><ul><li>用户轻量级的<br>NSUserDefaults对象是用来保存，恢复应用程序相关的偏好设置，配置数据等等。默认系统允许应用程序自定义它的行为去迎合用户的喜好。你可以在程序运行的时候从用户默认的数据库中读取程序的设置。同时NSUserDefaults的缓存避免了在每次读取数据时候都打开用户默认数据库的操作。可以通过调用synchronize方法来使内存中的缓存与用户默认系统进行同步。</li></ul><ul><li>存数据<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取NSUserDefaults 对象</span></span><br><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">      <span class="comment">// 存数据，不需要设置路径，NSUserDefaults 将数据保存在preferrences目录下</span></span><br><span class="line">[userDefaults setObject:<span class="string">@"Jane"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">[userDefaults setObject:<span class="string">@"phone"</span> forKey:<span class="string">@"1892233232"</span>];</span><br><span class="line">    <span class="comment">// 立刻保存同步数据，（如果不写这句话，会在将来某个时间点将数据保存在preference目录下）</span></span><br><span class="line">[userDefaults synchronize];</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>取数据</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取NSUserDefaults对象</span></span><br><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line"><span class="built_in">NSString</span> *userName  = [userDefaults objectForKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *userPhone  = [userDefaults objectForKey:<span class="string">@"phone"</span>];</span><br></pre></td></tr></table></figure></li><li><p>判断一个数据是否存储在NSUserDefaults 中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([userDefaults objectForKey:<span class="string">@"Kite"</span>] == <span class="literal">nil</span>) &#123;</span><br><span class="line">    nslog(<span class="string">@"没有存储Kite用户这个数据"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果存储 key 相同，value 不同的数据，后面的数据会把前面的数据替换掉。 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//执行完这行代码，文件中存储的数据就是现在的心value</span></span><br><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setObject:<span class="string">@"phone"</span> forKey:<span class="string">@"1877230212"</span>];</span><br><span class="line">[userDefaults synchronize];</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NSUserDefaults&quot;&gt;&lt;a href=&quot;#NSUserDefaults&quot; class=&quot;headerlink&quot; title=&quot;NSUserDefaults&quot;&gt;&lt;/a&gt;NSUserDefaults&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用户轻量级的&lt;br&gt;NSUser
      
    
    </summary>
    
      <category term="iOS" scheme="http://yikeshu.info/categories/iOS/"/>
    
    
      <category term="OC" scheme="http://yikeshu.info/tags/OC/"/>
    
  </entry>
  
  <entry>
    <title>CollectionView 拖拽移动</title>
    <link href="http://yikeshu.info/2017/02/18/CollectionView_dragMove/"/>
    <id>http://yikeshu.info/2017/02/18/CollectionView_dragMove/</id>
    <published>2017-02-18T09:54:30.000Z</published>
    <updated>2017-02-18T09:54:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iOS9新特性，collectionView的退拽"><a href="#iOS9新特性，collectionView的退拽" class="headerlink" title="iOS9新特性，collectionView的退拽"></a>iOS9新特性，collectionView的退拽</h3><ul><li>创建collectionView，实现代理方法和Datasource，向collectionView 添加长按事件，如下这是我创建collectionView，注册的cell。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UICollectionView</span> *)collectionView &#123;</span><br><span class="line"><span class="keyword">if</span>(_collectionView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">UICollectionViewFlowLayout</span> *flowLayout = [[<span class="built_in">UICollectionViewFlowLayout</span> alloc] init];</span><br><span class="line">        flowLayout.itemSize = <span class="built_in">CGSizeMake</span>(<span class="number">45</span>, <span class="number">45</span>);</span><br><span class="line">        flowLayout.minimumLineSpacing = <span class="number">10</span>;</span><br><span class="line">        flowLayout.minimumInteritemSpacing = <span class="number">10</span>;</span><br><span class="line">        flowLayout.sectionInset = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">        _collectionView = [[<span class="built_in">UICollectionView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, KScreenWidth, KScreenHeight) collectionViewLayout:flowLayout];</span><br><span class="line">        _collectionView.delegate = <span class="keyword">self</span>;</span><br><span class="line">        _collectionView.dataSource = <span class="keyword">self</span>;</span><br><span class="line">        _collectionView.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        [_collectionView registerClass:[MoveCollectionViewCell <span class="keyword">class</span>] forCellWithReuseIdentifier:identity];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UILongPressGestureRecognizer</span> *longPressGesture = [[<span class="built_in">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(longPressAction:)];</span><br><span class="line">        [_collectionView addGestureRecognizer:longPressGesture];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> _collectionView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现datasource ，加入数据源，</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView numberOfItemsInSection:(<span class="built_in">NSInteger</span>)section &#123;</span><br><span class="line">    <span class="keyword">return</span> _data.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    MoveCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:identity forIndexPath:indexPath];</span><br><span class="line">    cell.img = _data[indexPath.row];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面使用iOS9的新特性实现拖拽，必须实现下面的方法<a id="more"></a></li><li>开始移动的时候调用此方法，可以获取相应的datasource方法设置特殊的indexpath 能否移动,如果能移动返回的是YES ,不能移动返回的是NO</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)beginInteractiveMovementForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br></pre></td></tr></table></figure><ul><li>更新移动过程的位置</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateInteractiveMovementTargetPosition:(<span class="built_in">CGPoint</span>)targetPosition</span><br></pre></td></tr></table></figure><ul><li>结束移动的时候调用此方法，collectionView 会响应相应的datasource方法，collectionView:moveItemAtIndexPath:toIndexPath:  我们可以在这个方法中将移动的数据源，与目标数据源交互位置。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)endInteractiveMovement</span><br></pre></td></tr></table></figure><ul><li>取消移动的时候调用，会返回最原始的位置。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cancelInteractiveMovement;</span><br></pre></td></tr></table></figure><ul><li>在开始移动的时候会调用这个方法，如果有特殊的单元格不想被移动可以return NO， 如果没有限制就返回YES 吧。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView canMoveItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明            </th></tr></thead><tbody><tr><td style="text-align:left">collectionView</td><td style="text-align:left">调用这个代理方法的 collection View</td></tr><tr><td style="text-align:left">indexPath</td><td style="text-align:left">collectionView 中想要移动的 indexpath</td></tr></tbody></table><ul><li>移动结束的时候会调用此datasource，想要拖拽完成之后数据正确必须实现此方法，使用新的路径更新数据源，如果不实现此方法，刚刚移动cell中的数据不会重新排列。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView moveItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)sourceIndexPath</span><br><span class="line">           toIndexPath:(<span class="built_in">NSIndexPath</span> *)destinationIndexPath</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明            </th></tr></thead><tbody><tr><td style="text-align:left">collectionView</td><td style="text-align:left">正在响应这个方法的collectionView</td></tr><tr><td style="text-align:left">sourceIndexPath</td><td style="text-align:left">原始移动的indexpath</td></tr><tr><td style="text-align:left">destinationIndexPath</td><td style="text-align:left">移动到目标位置的indexpath</td></tr></tbody></table><ul><li>刚刚我们已经给collectionView 添加了长按的手势，目的就是长按的时候，可以拖动cell来进行移动，那怎么开始移动呢？我们来实现长按事件看看。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)longPressAction:(<span class="built_in">UILongPressGestureRecognizer</span> *)longPress &#123;</span><br><span class="line">    <span class="comment">//获取此次点击的坐标，根据坐标获取cell对应的indexPath</span></span><br><span class="line">    <span class="built_in">CGPoint</span> point = [longPress locationInView:_collectionView];</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span>.collectionView indexPathForItemAtPoint:point];</span><br><span class="line">    <span class="comment">//根据长按手势的状态进行处理。</span></span><br><span class="line">    <span class="keyword">switch</span> (longPress.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>:</span><br><span class="line">            <span class="comment">//当没有点击到cell的时候不进行处理</span></span><br><span class="line">            <span class="keyword">if</span> (!indexPath) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开始移动</span></span><br><span class="line">            [_collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>:</span><br><span class="line">        <span class="comment">//移动过程中更新位置坐标</span></span><br><span class="line">            [_collectionView updateInteractiveMovementTargetPosition:point];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:</span><br><span class="line">        <span class="comment">//停止移动调用此方法</span></span><br><span class="line">            [_collectionView endInteractiveMovement];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//取消移动</span></span><br><span class="line">            [_collectionView cancelInteractiveMovement];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面这两个方法都需要实现。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在开始移动时会调用此代理方法，</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView canMoveItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">//根据indexpath判断单元格是否可以移动，如果都可以移动，直接就返回YES ,不能移动的返回NO</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在移动结束的时候调用此代理方法</span></span><br><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView moveItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)sourceIndexPath toIndexPath:(<span class="built_in">NSIndexPath</span>*)destinationIndexPath &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *sourceIndexPath 原始数据 indexpath</span></span><br><span class="line"><span class="comment">     * destinationIndexPath 移动到目标数据的 indexPath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    [_data removeObjectAtIndex:sourceIndexPath.row];</span><br><span class="line">    <span class="built_in">UIImage</span> *img = _data[sourceIndexPath.row]</span><br><span class="line">    [_data insertObject:img atIndex:destinationIndexPath.row];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="自己写collectionView拖拽的方法"><a href="#自己写collectionView拖拽的方法" class="headerlink" title="自己写collectionView拖拽的方法"></a>自己写collectionView拖拽的方法</h3><ul><li><p>如果你的手机支持iOS9或更高版本，使用苹果为我们提供的方法实现拖拽功能是没有问题的。相信还有很多都在支持ios8，所以下面的方法也许很适用。</p><ul><li><p>在<strong>- (UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</strong> 方法中，为每个cell添加长按手势，这样就可以在你长按cell的时候响应事件。</p></li><li><p>下面我们看看长按事件中应该实现怎样的方法。</p></li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)longPressAction:(<span class="built_in">UILongPressGestureRecognizer</span> *)longPress &#123;</span><br><span class="line">   <span class="comment">//获取当前cell所对应的indexpath </span></span><br><span class="line">   MoveCollectionViewCell *cell = (MoveCollectionViewCell *)longPress.view;</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *cellIndexpath = [_collectionView indexPathForCell:cell];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将此cell 移动到视图的前面</span></span><br><span class="line">    [_collectionView bringSubviewToFront:cell];</span><br><span class="line">    _isChange = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (longPress.state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>: &#123;</span><br><span class="line">        <span class="comment">//使用数组将collectionView每个cell的 UICollectionViewLayoutAttributes 存储起来。</span></span><br><span class="line">            [<span class="keyword">self</span>.cellAttributesArray removeAllObjects];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.data.count; i++) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.cellAttributesArray addObject:[_collectionView layoutAttributesForItemAtIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForRow:i inSection:<span class="number">0</span>]]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>: &#123;</span><br><span class="line">            <span class="comment">//在移动过程中，使cell的中心与移动的位置相同。</span></span><br><span class="line">            cell.center = [longPress locationInView:_collectionView];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">UICollectionViewLayoutAttributes</span> *attributes <span class="keyword">in</span> <span class="keyword">self</span>.cellAttributesArray) &#123;</span><br><span class="line">            <span class="comment">//判断移动cell的indexpath，是否和目的位置相同，如果相同isChange为YES,然后将数据源交换</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(attributes.frame, cell.center) &amp;&amp; cellIndexpath != attributes.indexPath) &#123;</span><br><span class="line">                    _isChange = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="built_in">NSString</span> *imgStr = <span class="keyword">self</span>.data[cellIndexpath.row];</span><br><span class="line">                    [<span class="keyword">self</span>.data removeObjectAtIndex:cellIndexpath.row];</span><br><span class="line">                    [<span class="keyword">self</span>.data insertObject:imgStr atIndex:attributes.indexPath.row];</span><br><span class="line">                    [<span class="keyword">self</span>.collectionView moveItemAtIndexPath:cellIndexpath toIndexPath:attributes.indexPath];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>: &#123;</span><br><span class="line">            <span class="comment">//如果没有改变，直接返回原始位置</span></span><br><span class="line">            <span class="keyword">if</span> (!_isChange) &#123;</span><br><span class="line">                cell.center = [_collectionView layoutAttributesForItemAtIndexPath:cellIndexpath].center;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 不使用iOS9的代理方法，实现拖拽移动也很简单,可以试试。<br> 代码已经放到github仓库请点击这里 <strong><a href="https://github.com/oneMoreTime1357/CollectionViewTips" target="_blank" rel="noopener">项目链接</a></strong> 查看</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;iOS9新特性，collectionView的退拽&quot;&gt;&lt;a href=&quot;#iOS9新特性，collectionView的退拽&quot; class=&quot;headerlink&quot; title=&quot;iOS9新特性，collectionView的退拽&quot;&gt;&lt;/a&gt;iOS9新特性，collectionView的退拽&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;创建collectionView，实现代理方法和Datasource，向collectionView 添加长按事件，如下这是我创建collectionView，注册的cell。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UICollectionView&lt;/span&gt; *)collectionView &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(_collectionView == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;UICollectionViewFlowLayout&lt;/span&gt; *flowLayout = [[&lt;span class=&quot;built_in&quot;&gt;UICollectionViewFlowLayout&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        flowLayout.itemSize = &lt;span class=&quot;built_in&quot;&gt;CGSizeMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;45&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;45&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        flowLayout.minimumLineSpacing = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        flowLayout.minimumInteritemSpacing = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        flowLayout.sectionInset = &lt;span class=&quot;built_in&quot;&gt;UIEdgeInsetsMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _collectionView = [[&lt;span class=&quot;built_in&quot;&gt;UICollectionView&lt;/span&gt; alloc] initWithFrame:&lt;span class=&quot;built_in&quot;&gt;CGRectMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, KScreenWidth, KScreenHeight) collectionViewLayout:flowLayout];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _collectionView.delegate = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _collectionView.dataSource = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _collectionView.backgroundColor = [&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; whiteColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_collectionView registerClass:[MoveCollectionViewCell &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;] forCellWithReuseIdentifier:identity];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;UILongPressGestureRecognizer&lt;/span&gt; *longPressGesture = [[&lt;span class=&quot;built_in&quot;&gt;UILongPressGestureRecognizer&lt;/span&gt; alloc] initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; action:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(longPressAction:)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_collectionView addGestureRecognizer:longPressGesture];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _collectionView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;实现datasource ，加入数据源，&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)collectionView:(&lt;span class=&quot;built_in&quot;&gt;UICollectionView&lt;/span&gt; *)collectionView numberOfItemsInSection:(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)section &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _data.count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UICollectionViewCell&lt;/span&gt; *)collectionView:(&lt;span class=&quot;built_in&quot;&gt;UICollectionView&lt;/span&gt; *)collectionView cellForItemAtIndexPath:(&lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *)indexPath &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MoveCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:identity forIndexPath:indexPath];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cell.img = _data[indexPath.row];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cell;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;下面使用iOS9的新特性实现拖拽，必须实现下面的方法
    
    </summary>
    
      <category term="iOS" scheme="http://yikeshu.info/categories/iOS/"/>
    
    
      <category term="OC" scheme="http://yikeshu.info/tags/OC/"/>
    
  </entry>
  
</feed>
