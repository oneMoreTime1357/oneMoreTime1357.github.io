<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MissYang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yikeshu.info/"/>
  <updated>2018-10-17T11:07:36.281Z</updated>
  <id>http://yikeshu.info/</id>
  
  <author>
    <name>Sunny Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Promise.all 处理error</title>
    <link href="http://yikeshu.info/2018/10/17/Promise-all-handle-error/"/>
    <id>http://yikeshu.info/2018/10/17/Promise-all-handle-error/</id>
    <published>2018-10-17T11:06:48.969Z</published>
    <updated>2018-10-17T11:07:36.281Z</updated>
    
    <content type="html"><![CDATA[<p><code>Promise.all()</code>接受一个由promise任务组成的数组，可以同时处理多个promise任务，当所有的任务都执行完成时，<code>Promise.all()</code>返回resolve，但当有一个失败(reject)，则返回失败的信息，即使其他promise执行成功，也会返回失败。可以用一句话来说<code>Promise.all()</code>，要么全有要么全无。<br><a id="more"></a><br>但话又说回来，有时候我们使用<code>Promise.all()</code>执行很多个网络请求，可能有一个请求出错，但我们并不希望其他的网络请求也返回reject，要错都错，这样显然是不合理的。</p><p>而我们需要的是即使有一两个接口请求失败，我们依然可以获取到成功的接口请求数据。</p><p>要想理解<code>Promise.all()</code>的机制请看上一篇《理解promise》中的Promise.All示例</p><p>那下面说说如何做才能做到promise.all中即使一个promise程序reject，promise.all依然能把其他数据正确返回。</p><p><strong>首先我们先创建一个resolve和reject的promise函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const promiseResove = (promiseResolveSecond = function(n=0)&#123;</span><br><span class="line">    return new Promise(function(resolve, reject)&#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            resolve(&#123;</span><br><span class="line">                resolveAfterSeconds: n</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, n * 100);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const promiseReject = (promiseRejectSecond = function(n=0) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            reject(&#123;</span><br><span class="line">                rejectAfterSeconds: n</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, n * 100)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>使用上面的函数创建一个所有结果能正确返回的promise.all程序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var promiseArray = []</span><br><span class="line">promiseArray.push(promiseResove(1))</span><br><span class="line">promiseArray.push(promiseResove(3))</span><br><span class="line">promiseArray.push(promiseResove(2))</span><br><span class="line"></span><br><span class="line">var handlePromise = Promise.all(promiseArray)</span><br><span class="line">handlePromise.then(function(values) &#123;</span><br><span class="line">    console.log(&apos;all promise are resolved&apos;, values)</span><br><span class="line">&#125;).catch(function(reason) &#123;</span><br><span class="line">    console.log(&apos;promise reject failed reason&apos;, reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>执行结果如下<br><img src="http://oybj22zxs.bkt.clouddn.com/19_49_30__08_01_2018.jpg" alt="promise all resolve"></li></ul><p><strong>然后在创建一个拥有reject函数返回的promise</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var promiseArray = []</span><br><span class="line">promiseArray.push(promiseResove(1))</span><br><span class="line">promiseArray.push(promiseReject(3))</span><br><span class="line">promiseArray.push(promiseResove(2))</span><br><span class="line"></span><br><span class="line">var handlePromise = Promise.all(promiseArray)</span><br><span class="line">handlePromise.then(function(values) &#123;</span><br><span class="line">    console.log(&apos;all promise are resolved&apos;, values)</span><br><span class="line">&#125;).catch(function(reason) &#123;</span><br><span class="line">    console.log(&apos;promise reject failed reason&apos;, reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>执行结果如下<br><img src="http://oybj22zxs.bkt.clouddn.com/19_53_41__08_01_2018.jpg" alt="promise all with reject"></li></ul><p>当<code>promise.all</code>中有一个promise执行失败返回reject时，promise.all直接返回执行失败的promise结果。</p><p>但我们还想看到其他两个resolve的结果，所以后面用一个trick方法，来解决这个问题。</p><p><strong>代码修改如下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var promiseArray = []</span><br><span class="line">promiseArray.push(promiseResove(1))</span><br><span class="line">promiseArray.push(promiseReject(3))</span><br><span class="line">promiseArray.push(promiseResove(2))</span><br><span class="line"></span><br><span class="line">// 将传入promise.all的数组进行遍历，如果catch住reject结果，</span><br><span class="line">// 直接返回，这样就可以在最后结果中将所有结果都获取到</span><br><span class="line">var handlePromise = Promise.all(promiseArray.map(function(promiseItem) &#123;</span><br><span class="line">return promiseItem.catch(function(err) &#123;</span><br><span class="line">    return err</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;))</span><br><span class="line">handlePromise.then(function(values) &#123;</span><br><span class="line">    console.log(&apos;all promise are resolved&apos;, values)</span><br><span class="line">&#125;).catch(function(reason) &#123;</span><br><span class="line">    console.log(&apos;promise reject failed reason&apos;, reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和之前唯一的不同就是在promise数组添加了一个回调函数，当数组中有接口reject时，catch住结果直接返回，这样失败的结果也可以当做成功处理，所以在promise.all中我们可以监听到所有结果的返回，然后在针对不同的返回值进行处理。</p><hr><p>参考链接<br><a href="https://stackoverflow.com/questions/30362733/handling-errors-in-promise-all" target="_blank" rel="noopener">https://stackoverflow.com/questions/30362733/handling-errors-in-promise-all</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Promise.all()&lt;/code&gt;接受一个由promise任务组成的数组，可以同时处理多个promise任务，当所有的任务都执行完成时，&lt;code&gt;Promise.all()&lt;/code&gt;返回resolve，但当有一个失败(reject)，则返回失败的信息，即使其他promise执行成功，也会返回失败。可以用一句话来说&lt;code&gt;Promise.all()&lt;/code&gt;，要么全有要么全无。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yikeshu.info/categories/JS/"/>
    
    
  </entry>
  
  <entry>
    <title>Web 优化script link load</title>
    <link href="http://yikeshu.info/2018/10/17/web-script-link-load/"/>
    <id>http://yikeshu.info/2018/10/17/web-script-link-load/</id>
    <published>2018-10-17T11:03:37.376Z</published>
    <updated>2018-10-17T11:05:23.744Z</updated>
    
    <content type="html"><![CDATA[<p>针对网站初始化时脚本下载的优化</p><a id="more"></a><h3 id="async-amp-amp-defer"><a href="#async-amp-amp-defer" class="headerlink" title="async &amp;&amp; defer"></a>async &amp;&amp; defer</h3><script src="script.js"></script><p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。</p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</p><p><img src="https://segmentfault.com/img/bVWhRl?w=801&amp;h=814" alt="图片解说"></p><h4 id="Nuxt-添加defer"><a href="#Nuxt-添加defer" class="headerlink" title="Nuxt 添加defer"></a>Nuxt 添加defer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; src: &apos;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js&apos;, defer: true &#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>defer和async都不会阻止Document的解析，都是异步</li><li>defer会在DOMContentLoaded前依次按照加载顺序执行脚本</li><li>async则是下载完立即执行，不一定是在DOMContentLoaded前</li><li>async因为顺序无关，所以很适合Google Analytics这样的无依赖脚本</li></ul><h3 id="prefetch"><a href="#prefetch" class="headerlink" title="prefetch"></a>prefetch</h3><p><strong>MDN 解释 prefetch</strong></p><blockquote><p>link prefetch 是一种浏览器机制，其利用浏览器空闲时间来下载或预取用户在不久的将来可能访问的文档。页面向浏览器提供一组预取提示，并在浏览器完成当前页面的加载后开始静默的拉取执行的文档并将其存储在缓存中。当用户访问其中一个预取文档时，便可以快速的从浏览器缓存中得到</p></blockquote><h4 id="预加载Link-prefetch写法"><a href="#预加载Link-prefetch写法" class="headerlink" title="预加载Link prefetch写法"></a>预加载Link prefetch写法</h4><p>HTML5页面资源预加载/预读取功能是通过Link标记实现的，将rel属性指定为prefetch，在href属性指定要加载的资源地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;/images/big.jpeg&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="prefetch在什么情况下使用"><a href="#prefetch在什么情况下使用" class="headerlink" title="prefetch在什么情况下使用"></a>prefetch在什么情况下使用</h4><ul><li>当页面有幻灯片类似的服务时，预加载/预读取接下来的1-3页和之前的1-3页。</li><li>预加载那些整个网站通用的图片。</li><li>预加载网站上搜索结果的下一页。</li></ul><h4 id="预加载注意事项"><a href="#预加载注意事项" class="headerlink" title="预加载注意事项"></a>预加载注意事项</h4><ul><li>预加载(Link prefetch)不能跨域工作，包括跨域拉取cookies。</li><li>预加载(Link prefetch)会污染你的网站访问量统计，因为有些预加载到浏览器的页面用户可能并未真正访问。</li><li>火狐浏览器从2003年开始就已经提供了对这项预加载(Link prefetch)技术的支持</li></ul><hr><p><strong>参考链接</strong></p><p><a href="http://www.webhek.com/post/link-prefetch.html" target="_blank" rel="noopener">H5页面预加载Link prefetch加速页面</a></p><p><a href="https://segmentfault.com/q/1010000000640869" target="_blank" rel="noopener">defer和async区别</a></p><p><a href="https://github.com/xiaoyu2er/blog/issues/8" target="_blank" rel="noopener">defer &amp;&amp; async</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;针对网站初始化时脚本下载的优化&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://yikeshu.info/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>JS 数字补零的几种方法</title>
    <link href="http://yikeshu.info/2018/10/17/js-%E8%A1%A5%E9%9B%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yikeshu.info/2018/10/17/js-补零的方法/</id>
    <published>2018-10-17T06:40:27.083Z</published>
    <updated>2018-10-17T11:05:28.167Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍几种补零的方法</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 简单的for 循环补零</span><br><span class="line"></span><br><span class="line">function addPrefix1 (num, length) &#123;</span><br><span class="line">  for (var i = num.toString().length; i &lt; length; i++) &#123;</span><br><span class="line">    num = &apos;0&apos; + num</span><br><span class="line">  &#125;</span><br><span class="line">  return num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用递归的方式添加</span><br><span class="line">function addPrefix2 (num, length) &#123;</span><br><span class="line">  if (num.toString().length &gt;= length) &#123;</span><br><span class="line">    return num</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return addPrefix2(&apos;0&apos; + num, length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 转化为小数</span><br><span class="line">function addPrefix3 (num, length) &#123;</span><br><span class="line">  let decimal = num / Math.pow(10, length)</span><br><span class="line"></span><br><span class="line">  decimal = decimal.toFixed(length)</span><br><span class="line">  return decimal.substr(decimal.indexOf(&apos;.&apos;) + 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数组填充法</span><br><span class="line">function addPrefix4 (num, length) &#123;</span><br><span class="line">  return (Array(length).join(&apos;0&apos;) + num).slice(-length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 填充截取法</span><br><span class="line">function addPrefix5 (num, length) &#123;</span><br><span class="line">  var len = num.toString().length</span><br><span class="line">  var diff = length - len</span><br><span class="line">  if (diff &gt; 0) &#123;</span><br><span class="line">    return Array(diff).join(&apos;0&apos;) + num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let fix1 = addPrefix1(212, 8)</span><br><span class="line">console.log(fix1) // 00000212</span><br><span class="line"></span><br><span class="line">let fix2 = addPrefix2(21, 8)</span><br><span class="line">console.log(fix2) // 00000021</span><br><span class="line"></span><br><span class="line">let fix3 = addPrefix3(21, 8)</span><br><span class="line">console.log(fix3) // 00000021</span><br><span class="line"></span><br><span class="line">let fix4 = addPrefix4(21, 8)</span><br><span class="line">console.log(fix4) // 00000021</span><br><span class="line"></span><br><span class="line">let fix5 = addPrefix4(21, 8)</span><br><span class="line">console.log(fix5) // 00000021</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍几种补零的方法&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yikeshu.info/categories/JS/"/>
    
    
      <category term="JS" scheme="http://yikeshu.info/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>有意思的Console</title>
    <link href="http://yikeshu.info/2018/09/09/2018-9-9-console/"/>
    <id>http://yikeshu.info/2018/09/09/2018-9-9-console/</id>
    <published>2018-09-09T13:30:16.083Z</published>
    <updated>2018-09-09T13:31:57.226Z</updated>
    
    <content type="html"><![CDATA[<p>看到了一篇文章觉得很有意思<br>原文是<strong><a href="https://medium.freecodecamp.org/how-you-can-improve-your-workflow-using-the-javascript-console-bdd7823a9472" target="_blank" rel="noopener">How you can improve your workflow using the JavaScript console</a></strong> 作者列举了Console的其他用法，算我孤陋寡闻了，平常Debug时只使用<code>Console.log</code>，看了这篇文章才知道有那么多有意思的方法，下面介绍给大家。<br><a id="more"></a></p><h2 id="什么是Console"><a href="#什么是Console" class="headerlink" title="什么是Console"></a>什么是Console</h2><p>JavaScript console 是现在浏览器的一个特性，它可以为开发者提供</p><ul><li>在网页上查看错误日志和警告日志</li><li>使用JS命令与网页交互</li><li>在浏览器中直接Debug项目访问DOM</li><li>分析网络活动</li></ul><p>基本上在浏览器里它授权你写，管理和监听JavaScript是否正确</p><h3 id="Console-log-Console-error-Console-warn-and-Console-info"><a href="#Console-log-Console-error-Console-warn-and-Console-info" class="headerlink" title="Console.log, Console.error, Console.warn and Console.info"></a>Console.log, Console.error, Console.warn and Console.info</h3><p>这些是最常见的方法，你可以传递多个参数，每个参数都被计算并连接到一个由空格分隔的字符串中，但是objec对象和array数组例外，它们是通过属性进行分隔。<br><img src="http://oybj22zxs.bkt.clouddn.com/screenshot1.png" alt="screenshot1"></p><h3 id="Console-group"><a href="#Console-group" class="headerlink" title="Console.group"></a>Console.group</h3><p>这个方法允许你将一系列的console.log进行分组（包括 error info 等），在这个组中可以进行折叠。语法也非常简单，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function doSomthing (parm) &#123;</span><br><span class="line">console.group(&apos;group start&apos;)</span><br><span class="line">console.log(&apos;date print&apos;, new Date())</span><br><span class="line">console.log(123)</span><br><span class="line">console.groupEnd()</span><br><span class="line">console.log(&apos;out the group&apos;)</span><br><span class="line">&#125;</span><br><span class="line">doSomthing()</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="http://oybj22zxs.bkt.clouddn.com/screenshot2.png" alt="screenshot2"></p><h3 id="Console-table"><a href="#Console-table" class="headerlink" title="Console.table"></a>Console.table</h3><p>当遇到特别大的JSON和数组时<code>console.log</code>打印出来很糟糕，<code>console.table</code>可以让我们看到可视化的数据结构，还可以命名列表的名字只需要传递参数进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const typeConsole = [</span><br><span class="line">    &#123;name: &apos;log&apos;, type: &apos;standard&apos;&#125;,</span><br><span class="line">    &#123;name: &apos;info&apos;, type: &apos;standard&apos;&#125;,</span><br><span class="line">    &#123;name: &apos;table&apos;, type: &apos;wwwwowww&apos;&#125;</span><br><span class="line">]</span><br><span class="line">console.table(typeConsole)</span><br><span class="line">const mySocial = &#123;</span><br><span class="line">facebook: true,</span><br><span class="line">linkedin: true,</span><br><span class="line">weibo: false,</span><br><span class="line">meduim: false</span><br><span class="line">&#125;</span><br><span class="line">console.table(mySocial, [&quot;Social&quot;, &quot;have Account&quot;])</span><br></pre></td></tr></table></figure><p>结果输出如下<br><img src="http://oybj22zxs.bkt.clouddn.com/screenshot3.png" alt="screenshot3"></p><p>第二种打印的方法并没有在列的标题上展示我自定义的文字。</p><h3 id="Console-count-Console-time-and-Console-timeEnd"><a href="#Console-count-Console-time-and-Console-timeEnd" class="headerlink" title="Console.count, Console.time and Console.timeEnd"></a>Console.count, Console.time and Console.timeEnd</h3><p>对于每个开发者在debug时，这三个方法就像是瑞士军刀一样好用。<code>console.count</code>统计并输出相同的标签被执行多少次。<code>console.time</code>以指定参数的名称作为开始计时器，并且可以在给定页面上同时运行10,000个计时器。我们可以使用<code>console.timeEnd</code>停止计时器并在控制台打印出收集的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.time(&apos;time start&apos;)</span><br><span class="line">console.time(&apos;init arr&apos;)</span><br><span class="line">const arr = new Array(20)</span><br><span class="line">console.timeEnd(&apos;init arr&apos;)</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">arr[i] = new Object()</span><br><span class="line">const _type = (i %2 === 0) ? &apos;even &apos; : &apos;odd &apos;</span><br><span class="line">console.count(_type + &apos;added&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.timeEnd(&apos;time start&apos;)</span><br></pre></td></tr></table></figure><p>输出如下：<img src="http://oybj22zxs.bkt.clouddn.com/screenshot4.png" alt="screenshot4"></p><h3 id="Console-trace-and-Console-assert"><a href="#Console-trace-and-Console-assert" class="headerlink" title="Console.trace and Console.assert"></a>Console.trace and Console.assert</h3><p>这些方法只是简单的从调用它的地方打印堆栈跟踪。想象一下在创建JS库的时候想知道用户什么时候会触发这个error。在这种情况下这个方法很管用。<code>console.assert</code>和<code>console.trace</code>很像，但是只在条件不满足时才执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function lesserThan (a, b) &#123;</span><br><span class="line">console.assert(a &lt; b, &#123;&quot;message&quot;: &quot;a is not lesser than b&quot;, &quot;a&quot;: a, &quot;b&quot;: b&#125;)</span><br><span class="line">&#125;</span><br><span class="line">lesserThan(6,5)</span><br><span class="line">console.trace(&apos;enddd&apos;)</span><br></pre></td></tr></table></figure><p>输出如下：当输入6，5时</p><p><img src="http://oybj22zxs.bkt.clouddn.com/screenshot.png" alt="screenshot"></p><h3 id="删除所有的Consoles"><a href="#删除所有的Consoles" class="headerlink" title="删除所有的Consoles"></a>删除所有的Consoles</h3><p>使用完console之后经常需要我们清除它们。有时我们忘了清除直接发到了生产环境（经过了好长时间才注意到）。当然也不建议滥用console在不需要的地方（当控制台得出正确的结果最好将它删除），把错误日志和trace日志保留在开发环境帮助debug。作者经常使用Webpack在工作中或者自己的项目中。这有一个工具可以删除所有你不需要的console在生产环境构建的时候，它是<a href="https://github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="noopener">uglifyjs-webpack-plugin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)</span><br><span class="line">var debug = process.env.NODE_ENV !== &quot;production&quot;;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">optimization: &#123;</span><br><span class="line">        minimizer: !debug ? [</span><br><span class="line">            new UglifyJsPlugin(&#123;</span><br><span class="line">                // Compression specific options</span><br><span class="line">                uglifyOptions: &#123;</span><br><span class="line">                    // Eliminate comments</span><br><span class="line">                    comments: false,</span><br><span class="line">                    compress: &#123;</span><br><span class="line">                       // remove warnings</span><br><span class="line">                       warnings: false,</span><br><span class="line">                       // Drop console statements</span><br><span class="line">                       drop_console: true</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;)] : []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又增多了几个debug的技能，技术之路探索永不止息。<br>跟着作者的节奏打开浏览器控制台，跟着上面的代码进行操练吧，就会掌握这种调试技巧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到了一篇文章觉得很有意思&lt;br&gt;原文是&lt;strong&gt;&lt;a href=&quot;https://medium.freecodecamp.org/how-you-can-improve-your-workflow-using-the-javascript-console-bdd7823a9472&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How you can improve your workflow using the JavaScript console&lt;/a&gt;&lt;/strong&gt; 作者列举了Console的其他用法，算我孤陋寡闻了，平常Debug时只使用&lt;code&gt;Console.log&lt;/code&gt;，看了这篇文章才知道有那么多有意思的方法，下面介绍给大家。&lt;br&gt;
    
    </summary>
    
      <category term="Web" scheme="http://yikeshu.info/categories/Web/"/>
    
    
      <category term="JS" scheme="http://yikeshu.info/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>理解Promise - 学习</title>
    <link href="http://yikeshu.info/2018/08/05/understand-promise/"/>
    <id>http://yikeshu.info/2018/08/05/understand-promise/</id>
    <published>2018-08-05T12:50:56.650Z</published>
    <updated>2018-08-05T12:52:21.974Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript是同步编程语言，但是我们可以通过回调函数，使他看起来像异步编程语言。</p><p>Promise为了解决什么？<br>Node.js用回调函数代替了事件，使异步编程在JavaScript上更加流行。但当更多程序开始使用异步编程时，事件和回调函数却不能满足开发者想要做的所有事情，它们还不够强大，而Promise就是这些问题的解决方案。<br><a id="more"></a><br><strong><a href="https://hackernoon.com/understanding-promises-in-javascript-13d99df067c1" target="_blank" rel="noopener">Understanding promises in JavaScript</a></strong> 这篇文章描述了两个部分用于理解 promise，一是创建promise，二是处理promise。本文是在学习此文的基础上加入了一些自己的理解，大部分代码都是学习原文作者。原文内容更丰富，建议阅读原文。</p><p>作者在帮助理解Promise上举了很多例子，在阅读的过程中最好打开浏览器的控制台，边看边执行代码验证结果，帮助理解。而且例子贴近生活更便于理解。</p><h2 id="创建Promise"><a href="#创建Promise" class="headerlink" title="创建Promise"></a>创建Promise</h2><p>创建一个promise标准的写法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Promise( /* executor */ function(resolve, reject) &#123; ... &#125; );</span><br></pre></td></tr></table></figure></p><p>这个构造函数接收一个执行函数，执行函数接收两个参数<code>resolve</code>和<code>reject</code>。Promise一般用于处理一些简单的异步程序和代码块，比如文件程序，API调用，DB调用，IO操作。异步程序初始化是在 executor 这个函数中初始化。如果这个异步程序执行成功，使用resolve函数返回，如果执行失败使用 reject函数返回。</p><p>下面创建一个简单的promise函数，在浏览器控制台执行下面的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var keepsHisWord;</span><br><span class="line">keepsHisWord = true;</span><br><span class="line">promise1 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  if (keepsHisWord) &#123;</span><br><span class="line">    resolve(&quot;The man likes to keep his word&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(&quot;The man doesnt want to keep his word&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(promise1);</span><br></pre></td></tr></table></figure><p>想知道结果，请把代码复制下来在浏览器控制台执行看看吧。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*ByDQ6-tTp2TvHIh4R_P6xw.png" alt=""></p><p>由于这个promise立马就执行了，我们没有办法在这个promise中检查初始化情况。所以让我们再重新创建一个promise，这个promise需要点时间去resolve。简单的办法就是使用 setTimeout函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    resolve(&#123;</span><br><span class="line">      message: &quot;The man likes to keep his word&quot;,</span><br><span class="line">      code: &quot;aManKeepsHisWord&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, 10 * 1000);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(promise2);</span><br></pre></td></tr></table></figure><p>上方的代码只是创建了一个promise，在10秒钟之后无条件的 resolve。So,我们可以检查这个状况的promise，知道它resolve为止。<br><img src="https://cdn-images-1.medium.com/max/1600/1*6GX_rHpGa3HXcYiHm9Vy6g.png" alt=""></p><p>10秒钟过后，promise执行了resolve 方法，<code>PromiseStatus</code>和<code>PromiseValue</code>因此被更新。你可以看到，我们可以传递一个JSON对象代替一个简单string来更新resolve函数。因此我们也可以传递其他的数据到resolve函数中。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*n6s4IswZBVUIHc2K3apONA.png" alt=""></p><p>接下来让我们看看promise中的reject函数，简单修改上面的函数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">keepsHisWord = false;</span><br><span class="line">promise3 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  if (keepsHisWord) &#123;</span><br><span class="line">    resolve(&quot;The man likes to keep his word&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(&quot;The man doesn&apos;t want to keep his word&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(promise3);</span><br></pre></td></tr></table></figure><p>至此，我们创建了一个无法处理的reject promise，chrome浏览器将会显示错误提示。你可以先忽略，我们接下来会解释。<br><img src="https://cdn-images-1.medium.com/max/1600/1*rP1Qk-5xOz4c1MJmoNT0Bw.png" alt=""></p><p>如我们所看到的<code>PromiseStatus</code>有三个不同的值。<code>pending</code> <code>resolved</code> 和 <code>rejected</code>，当promise创建<code>PromiseStatus</code> 将会在<code>pending</code>状态下，此时的<code>PromiseValue</code>是<code>undefined</code> 知道promise <code>resolved</code>或者<code>rejected</code>。当一个promise在<code>resolved</code>或者<code>rejected</code>状态下，这个promise可以说是<code>settled</code>已经被解决。所以一个promise的状态通常是从 pending状态 到 settled状态。</p><p>上面我们已经知道了怎么创建promise，接下来我们将要学习如何使用和处理promise，手把手教你怎么理解<code>Promise</code>对象。</p><h2 id="理解promise对象"><a href="#理解promise对象" class="headerlink" title="理解promise对象"></a>理解promise对象</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promis在MDN文档</a>中解释如下</p><blockquote><p>Promise对象用于表示一个异步操作的最终状态(完成或失败)，以及其返回的值。</p></blockquote><p>Promise 对象有静态方法和原型方法，静态方法在Promise对象中可以被申请为独立的。记住不管是普通的方法还是原型方法，只要返回一个Promise对象，就会变得简单。</p><h3 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h3><p>promise有三个原型方法。所有的这些方法，处理不同的状态。正如上文的例子当一个Promise被创建，最开始是pending状态，下面的三个方法将会被执行，不管返回的是 fulfilled 或者 rejected 都会被解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.catch(onRejected)</span><br><span class="line">Promise.prototype.then(onFulfilled, onRejected)</span><br><span class="line">Promise.prototype.finally(onFinally)</span><br></pre></td></tr></table></figure><p>下面这张图片展示了 .then .catch方法。如果返回一个Promise，正如下面这张图片所示，会引起连锁反应。<br><img src="https://cdn-images-1.medium.com/max/1600/1*0mBlni5vsYZE2wFzfVv8EA.png" alt=""></p><p>下面作者举了一个例子，来帮助理解Promise。</p><p>例如：你是个学生，想让你妈妈给你买个手机，她说：“我将在这个月底给你买个手机”</p><p>让我们看看这个在JavaScript中怎么实现，如果这个承诺在月底执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var momsPromise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  momsSavings = 20000;</span><br><span class="line">  priceOfPhone = 60000;</span><br><span class="line">  if (momsSavings &gt; priceOfPhone) &#123;</span><br><span class="line">    resolve(&#123;</span><br><span class="line">      brand: &quot;iphone&quot;,</span><br><span class="line">      model: &quot;6s&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(&quot;We donot have enough savings. Let us save some more money.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">momsPromise.then(function(value) &#123;</span><br><span class="line">  console.log(&quot;Hurray I got this phone as a gift &quot;, JSON.stringify(value));</span><br><span class="line">&#125;);</span><br><span class="line">momsPromise.catch(function(reason) &#123;</span><br><span class="line">  console.log(&quot;Mom coudn&apos;t buy me the phone because &quot;, reason);</span><br><span class="line">&#125;);</span><br><span class="line">momsPromise.finally(function() &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &quot;Irrespecitve of whether my mom can buy me a phone or not, I still love her&quot;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出如下<br><img src="https://cdn-images-1.medium.com/max/1600/1*Ol16n8YEu5vKgVqh0pBbhg.png" alt=""></p><p>如果我们改变 <code>momSavings</code>到200000，愿望达成，输出如下<br><img src="https://cdn-images-1.medium.com/max/1600/1*9PPksLxayz3373AxoYg4kA.png" alt=""></p><p>我们模拟数据输出，这样我们就可以看到怎么有效的使用then和catch</p><p> .then 可以同时标记onFulfilled，onRejected handlers，我们可以将它们写在一起，代替分开的写法，我们可以使用 .then处理两种情况，如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> momsPromise.then(</span><br><span class="line">  function(value) &#123;</span><br><span class="line">    console.log(&quot;Hurray I got this phone as a gift &quot;, JSON.stringify(value));</span><br><span class="line">  &#125;,</span><br><span class="line">  function(reason) &#123;</span><br><span class="line">    console.log(&quot;Mom coudn&apos;t buy me the phone because &quot;, reason);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p> 除了可读性强了一些，最好还是分开写吧。</p><p> 为了更好的理解Promise，让我们创建一个函数返回promise，将会随机的返回resolved或者rejected，这样我们就可以测试多种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function getRandomNumber(start = 1, end = 10) &#123;</span><br><span class="line">  //works when both start,end are &gt;=1 and end &gt; start</span><br><span class="line">  return parseInt(Math.random() * end) % (end-start+1) + start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面将创建一返回promise的函数，使用随机函数，随机生成一个数，如果大于5将resolved，小于5返回 rejected，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function getRandomNumber(start = 1, end = 10) &#123;</span><br><span class="line">  //works when both start and end are &gt;=1</span><br><span class="line">  return (parseInt(Math.random() * end) % (end - start + 1)) + start;</span><br><span class="line">&#125;</span><br><span class="line">var promiseTRRARNOSG = (promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator = function() &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let randomNumberOfSeconds = getRandomNumber(2, 10);</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      let randomiseResolving = getRandomNumber(1, 10);</span><br><span class="line">      if (randomiseResolving &gt; 5) &#123;</span><br><span class="line">        resolve(&#123;</span><br><span class="line">          randomNumberOfSeconds: randomNumberOfSeconds,</span><br><span class="line">          randomiseResolving: randomiseResolving</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(&#123;</span><br><span class="line">          randomNumberOfSeconds: randomNumberOfSeconds,</span><br><span class="line">          randomiseResolving: randomiseResolving</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, randomNumberOfSeconds * 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">var testProimse = promiseTRRARNOSG();</span><br><span class="line">testProimse.then(function(value) &#123;</span><br><span class="line">  console.log(&quot;Value when promise is resolved : &quot;, value);</span><br><span class="line">&#125;);</span><br><span class="line">testProimse.catch(function(reason) &#123;</span><br><span class="line">  console.log(&quot;Reason when promise is rejected : &quot;, reason);</span><br><span class="line">&#125;);</span><br><span class="line">// Let us loop through and create ten different promises using the function to see some variation. Some will be resolved and some will be rejected. </span><br><span class="line">for (i=1; i&lt;=10; i++) &#123;</span><br><span class="line">  let promise = promiseTRRARNOSG();</span><br><span class="line">  promise.then(function(value) &#123;</span><br><span class="line">    console.log(&quot;Value when promise is resolved : &quot;, value);</span><br><span class="line">  &#125;);</span><br><span class="line">  promise.catch(function(reason) &#123;</span><br><span class="line">    console.log(&quot;Reason when promise is rejected : &quot;, reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刷新浏览器控制台，在控制台中执行上面的函数，观察不同的输出情况 resolve 和 reject。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>在Promise对象中，这里有四个静态方法</p><p>前两个方法可以快速的创建resolved 或者 rejected  promise函数</p><p>帮助你创建一个rejected promise</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(reason)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var promise3 = Promise.reject(&quot;Not interested&quot;);</span><br><span class="line">promise3.then(function(value)&#123;</span><br><span class="line">  console.log(&quot;This will not run as it is a resolved promise. The resolved value is &quot;, value);</span><br><span class="line">&#125;);</span><br><span class="line">promise3.catch(function(reason)&#123;</span><br><span class="line">  console.log(&quot;This run as it is a rejected promise. The reason is &quot;, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>帮助你创建一个resolved promise</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(value)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var promise4 = Promise.resolve(1);</span><br><span class="line">promise4.then(function(value)&#123;</span><br><span class="line">  console.log(&quot;This will run as it is a resovled promise. The resolved value is &quot;, value);</span><br><span class="line">&#125;);</span><br><span class="line">promise4.catch(function(reason)&#123;</span><br><span class="line">  console.log(&quot;This will not run as it is a resolved promise&quot;, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一个promise可以有多个处理程序，更新上面的代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var promise4 = Promise.resolve(1);</span><br><span class="line">promise4.then(function(value)&#123;</span><br><span class="line">  console.log(&quot;This will run as it is a resovled promise. The resolved value is &quot;, value);</span><br><span class="line">&#125;);</span><br><span class="line">promise4.then(function(value)&#123;</span><br><span class="line">  console.log(&quot;This will also run as multiple handlers can be added. Printing twice the resolved value which is &quot;, value * 2);</span><br><span class="line">&#125;);</span><br><span class="line">promise4.catch(function(reason)&#123;</span><br><span class="line">  console.log(&quot;This will not run as it is a resolved promise&quot;, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出如下：<br><img src="https://cdn-images-1.medium.com/max/1600/1*dXk3jy1wB9iTXujph1EbcA.png" alt=""></p><p>下面的两个方法帮助你处理 promises。当你处理多个promises，最好的方法是创建一个promises数组，然后在设置promises的时候做必要的操作。下面创建两个方法，一个将在几秒钟之后resolve，另一个在几秒钟之后reject。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var promiseTRSANSG = (promiseThatResolvesAfterNSecondsGenerator = function(</span><br><span class="line">  n = 0</span><br><span class="line">) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      resolve(&#123;</span><br><span class="line">        resolvedAfterNSeconds: n</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, n * 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var promiseTRJANSG = (promiseThatRejectsAfterNSecondsGenerator = function(</span><br><span class="line">  n = 0</span><br><span class="line">) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      reject(&#123;</span><br><span class="line">        rejectedAfterNSeconds: n</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, n * 1000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-All"><a href="#Promise-All" class="headerlink" title="Promise.All"></a>Promise.All</h3><p>MDN 文档解释如下</p><blockquote><p>Promise.all(iterable)方法返回一个<code>Promise</code>实例，此实例在<code>iterable</code>参数内所有的promise都完成(resolved)或参数中不包含promise时回调完成(resolve);如果参数中promise有一个失败（rejected），此实例回调失败（reject），失败原因的是一个失败<code>promise</code>结果。</p></blockquote><p><strong>示例1：</strong>当所有的promise都完成（resolved）。大多数都会设想这种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.time(&quot;Promise.All&quot;);</span><br><span class="line">var promisesArray = [];</span><br><span class="line">promisesArray.push(promiseTRSANSG(1));</span><br><span class="line">promisesArray.push(promiseTRSANSG(4));</span><br><span class="line">promisesArray.push(promiseTRSANSG(2));</span><br><span class="line">var handleAllPromises = Promise.all(promisesArray);</span><br><span class="line">handleAllPromises.then(function(values) &#123;</span><br><span class="line">  console.timeEnd(&quot;Promise.All&quot;);</span><br><span class="line">  console.log(&quot;All the promises are resolved&quot;, values);</span><br><span class="line">&#125;);</span><br><span class="line">handleAllPromises.catch(function(reason) &#123;</span><br><span class="line">  console.log(&quot;One of the promises failed with the following reason&quot;, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1600/1*_gAQxkb19weN6ajUgzi0WA.png" alt=""></p><p>我们从结果中得出两个重要的结论</p><ol><li>第三个promise花了两秒完成，上一个promise花了4秒完成。但是正如你看到的输出仍然保持有序的状态</li><li>上面的程序增加了一个timer用于记录<code>Promise.All</code>花了多长时间。如果promise是按顺序执行的需要花费 1+4+2=7秒。但是从我们的timer中可以看到只花费了4秒。这可以证明所有的promises是并行执行的。</li></ol><p><strong>示例2：</strong>当没有promises会发生什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.time(&quot;Promise.All&quot;);</span><br><span class="line">var promisesArray = [];</span><br><span class="line">promisesArray.push(1);</span><br><span class="line">promisesArray.push(4);</span><br><span class="line">promisesArray.push(2);</span><br><span class="line">var handleAllPromises = Promise.all(promisesArray);</span><br><span class="line">handleAllPromises.then(function(values) &#123;</span><br><span class="line">  console.timeEnd(&quot;Promise.All&quot;);</span><br><span class="line">  console.log(&quot;All the promises are resolved&quot;, values);</span><br><span class="line">&#125;);</span><br><span class="line">handleAllPromises.catch(function(reason) &#123;</span><br><span class="line">  console.log(&quot;One of the promises failed with the following reason&quot;, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1600/1*TETvAXYEHE4x58OdimRXww.png" alt=""></p><p>因为数组中没有promises，返回的promises是已完成的（resolved）</p><p><strong>示例3：</strong>当只有一个promises返回失败时会怎么样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">console.time(&quot;Promise.All&quot;);</span><br><span class="line">var promisesArray = [];</span><br><span class="line">promisesArray.push(promiseTRSANSG(1));</span><br><span class="line">promisesArray.push(promiseTRSANSG(5));</span><br><span class="line">promisesArray.push(promiseTRSANSG(3));</span><br><span class="line">**promisesArray.push(promiseTRJANSG(2));**</span><br><span class="line">promisesArray.push(promiseTRSANSG(4));</span><br><span class="line">var handleAllPromises = Promise.all(promisesArray);</span><br><span class="line">handleAllPromises.then(function(values) &#123;</span><br><span class="line">  console.timeEnd(&quot;Promise.All&quot;);</span><br><span class="line">  console.log(&quot;All the promises are resolved&quot;, values);</span><br><span class="line">&#125;);</span><br><span class="line">handleAllPromises.catch(function(reason) &#123;</span><br><span class="line">  console.timeEnd(&quot;Promise.All&quot;);</span><br><span class="line">  console.log(&quot;One of the promises failed with the following reason &quot;, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1600/1*y_NCGDEfc3PKctq5-ZO8iA.png" alt=""><br>当执行到失败程序时，promises里面停止并返回reject信息</p><p><strong>综上：</strong> <code>Promise.all()</code>只有在所有的promise数组都resolve时才会返回所有完成的数据。但要是数组中有一个promise任务失败，<code>Promise.all()</code>就会返回当前失败的promise信息，而就算其他的promise任务执行成功，也会返回reject。可以这么理解，<code>Promise.all()</code>返回结果要么是所有的，要么什么都没有。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>MDN文档说明</p><blockquote><p><strong>Promise.race(iterable)</strong>方法返回一个promise，一旦迭代器中的某个promise解决或拒绝，返回的promise就会解决或拒绝。</p></blockquote><p>示例1：promises优先解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">console.time(&quot;Promise.race&quot;);</span><br><span class="line">var promisesArray = [];</span><br><span class="line">promisesArray.push(promiseTRSANSG(4));</span><br><span class="line">promisesArray.push(promiseTRSANSG(3));</span><br><span class="line">promisesArray.push(promiseTRSANSG(2));</span><br><span class="line">promisesArray.push(promiseTRJANSG(3));</span><br><span class="line">promisesArray.push(promiseTRSANSG(4));</span><br><span class="line">var promisesRace = Promise.race(promisesArray);</span><br><span class="line">promisesRace.then(function(values) &#123;</span><br><span class="line">  console.timeEnd(&quot;Promise.race&quot;);</span><br><span class="line">  console.log(&quot;The fasted promise resolved&quot;, values);</span><br><span class="line">&#125;);</span><br><span class="line">promisesRace.catch(function(reason) &#123;</span><br><span class="line">  console.timeEnd(&quot;Promise.race&quot;);</span><br><span class="line">  console.log(&quot;The fastest promise rejected with the following reason &quot;, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1600/1*6za2DUGOKIxARTyfP5HihQ.png" alt=""></p><p>所以的promises并行执行，第三个promise在2秒内完成，只要这个promise完成，<code>Promise.race</code>被解决。</p><p>示例2：当promises中reject程序优先完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">console.time(&quot;Promise.race&quot;);</span><br><span class="line">var promisesArray = [];</span><br><span class="line">promisesArray.push(promiseTRSANSG(4));</span><br><span class="line">promisesArray.push(promiseTRSANSG(6));</span><br><span class="line">promisesArray.push(promiseTRSANSG(5));</span><br><span class="line">promisesArray.push(promiseTRJANSG(3));</span><br><span class="line">promisesArray.push(promiseTRSANSG(4));</span><br><span class="line">var promisesRace = Promise.race(promisesArray);</span><br><span class="line">promisesRace.then(function(values) &#123;</span><br><span class="line">  console.timeEnd(&quot;Promise.race&quot;);</span><br><span class="line">  console.log(&quot;The fasted promise resolved&quot;, values);</span><br><span class="line">&#125;);</span><br><span class="line">promisesRace.catch(function(reason) &#123;</span><br><span class="line">  console.timeEnd(&quot;Promise.race&quot;);</span><br><span class="line">  console.log(&quot;The fastest promise rejected with the following reason &quot;, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/1600/1*CvfsxAM8XbGZYTXo5KjiCA.png" alt=""></p><p>所有的promise并行执行。第四个promise在3秒内reject。只要这个完成，<code>Promise.race</code>返回rejected</p><p><strong>综上：</strong> <code>Promise.race()</code>传入的promise数组中，总是返回最先执行完的一个，不管是reject还是resolved</p><hr><p>作者在文章的最后也贴出了code gist上面例子的代码片段，如有需要可以在原文中查看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript是同步编程语言，但是我们可以通过回调函数，使他看起来像异步编程语言。&lt;/p&gt;
&lt;p&gt;Promise为了解决什么？&lt;br&gt;Node.js用回调函数代替了事件，使异步编程在JavaScript上更加流行。但当更多程序开始使用异步编程时，事件和回调函数却不能满足开发者想要做的所有事情，它们还不够强大，而Promise就是这些问题的解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yikeshu.info/categories/JS/"/>
    
    
  </entry>
  
  <entry>
    <title>解锁 Vue多页面应用</title>
    <link href="http://yikeshu.info/2018/07/14/%E8%A7%A3%E9%94%81Vue-multiple-application/"/>
    <id>http://yikeshu.info/2018/07/14/解锁Vue-multiple-application/</id>
    <published>2018-07-14T09:15:57.975Z</published>
    <updated>2018-07-14T09:28:44.266Z</updated>
    
    <content type="html"><![CDATA[<p>大部分使用Vue是构建单页面应用，但有时候我们也需要多页面应用，比如手机端的H5页面，可能这块需要一个H5页，另一块需要一个H5活动页，彼此相互独立，根本就没有什么关联，这时候还使用单页面应用增加了页面加载的速度，而且打包了一大堆和本页面无关的代码，增加了页面响应时间。</p><a id="more"></a><p><strong>准备工作：</strong><br>使用vue-cli构建工具，添加项目。<br>最近vue-cli发布了最新版本v3.0.0，如果使用最新版本的脚手架，就不会暴露出webpack的一些配置文件，没办法自定义了，所以本次配置多页面构建还是使用的Vue CLI 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br><span class="line"></span><br><span class="line">vue init webpack vue-mutile-page</span><br></pre></td></tr></table></figure></p><p>使用此模板创建的vue项目，集成的是webpack3，现在webpack已经升级到4了，暂时先按照模板来使用webpack3吧，先把架子搭好，后期想升级到最新也是可以的。</p><h4 id="单页面应用打包之后dist目录"><a href="#单页面应用打包之后dist目录" class="headerlink" title="单页面应用打包之后dist目录"></a>单页面应用打包之后dist目录</h4><p>直接使用模板创建的项目是单页面应用的，配置文件都是写好的，所以我们可以直接执行命令打包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p><p>打包完成之后会生成dist目录，只生成一个入口文件index.html，然后static中有打包好的js和css文件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── dist</span><br><span class="line">|    ├── index.html</span><br><span class="line">|    └── static</span><br><span class="line">|       ├── css</span><br><span class="line">|       └── js</span><br></pre></td></tr></table></figure></p><h2 id="多页面应用"><a href="#多页面应用" class="headerlink" title="多页面应用"></a>多页面应用</h2><p>上面是常见的单页面应用打包之后的目录，那多页面打包之后应该是什么样的呢？</p><p>多页面应用就意味着有多个页面，单页面打包之后只生成一个html文件，这个文件就是项目的入口文件，多页面也就是说每个页面都应该有一个自己的html文件，页面和页面之间是相互独立的，那在打包之后dist目录应该生成每个页面的html文件。比如我有page1和page2，dist目录中应该生成下面的结构，各自的页面名称对应各自的html文件。那要怎么做到呢，请看下文分解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── dist</span><br><span class="line">|    ├── page1.html</span><br><span class="line">|    ├── page1.html</span><br><span class="line">|    └── static</span><br><span class="line">|       ├── css</span><br><span class="line">|       │   </span><br><span class="line">|       └── js</span><br><span class="line">|</span><br></pre></td></tr></table></figure><h3 id="改写项目目录"><a href="#改写项目目录" class="headerlink" title="改写项目目录"></a>改写项目目录</h3><p>想要搭建多页面的应用，首先要改写刚刚生成的项目目录结构。</p><p>下面是我修改之后的目录结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .babelrc</span><br><span class="line">├── .editorconfig</span><br><span class="line">├── .eslintignore</span><br><span class="line">├── .eslintrc.js</span><br><span class="line">├── .gitignore</span><br><span class="line">├── .postcssrc.js</span><br><span class="line">├── README.md</span><br><span class="line">├── build</span><br><span class="line">│   ├── build.js</span><br><span class="line">│   ├── check-versions.js</span><br><span class="line">│   ├── utils.js</span><br><span class="line">│   ├── vue-loader.conf.js</span><br><span class="line">│   ├── webpack.base.conf.js</span><br><span class="line">│   ├── webpack.dev.conf.js</span><br><span class="line">│   └── webpack.prod.conf.js</span><br><span class="line">├── config</span><br><span class="line">│   ├── dev.env.js</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── prod.env.js</span><br><span class="line">│   └── test.env.js</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br><span class="line">│   ├── assets</span><br><span class="line">│   │   └── logo.png</span><br><span class="line">│   ├── components</span><br><span class="line">│   │   └── HelloWorld.vue</span><br><span class="line">│   └── pages</span><br><span class="line">│       ├── page1</span><br><span class="line">│       │   ├── App.vue</span><br><span class="line">│       │   ├── index.ejs</span><br><span class="line">│       │   └── index.js</span><br><span class="line">│       └── page2</span><br><span class="line">│           ├── App.vue</span><br><span class="line">│           ├── index.ejs</span><br><span class="line">│           └── index.js</span><br><span class="line">└── static</span><br></pre></td></tr></table></figure></p><p>修改的点</p><ol><li>在src文件下创建pages目录，这是我们创建多页面放置的地方</li><li>pages目录下是根据页面名称命名的文件夹，文件夹下包含三个文件，后缀为：<code>.vue .ejs .js</code>这三个文件，后缀为.vue 和 .js 的文件分别对应项目创建时的App.vue 和main.js文件，现在都放到页面文件中，.ejs文件对应的是根目录下的index.html文件，也就是项目的入口文件。</li><li>把src下的App.vue 和main.js删除，根目录下的index.html也删除，因为这些都已经移到页面中了。</li></ol><p>项目目录整理好之后，那接下来我们就可以写配置文件了，配置文件的修改都在build目录下。更改的目录主要有下面这几个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── build</span><br><span class="line">│   ├── utils.js</span><br><span class="line">│   ├── webpack.base.conf.js</span><br><span class="line">│   ├── webpack.dev.conf.js</span><br><span class="line">│   └── webpack.prod.conf.js</span><br></pre></td></tr></table></figure></p><h3 id="修改utils-js文件"><a href="#修改utils-js文件" class="headerlink" title="修改utils.js文件"></a>修改utils.js文件</h3><p>在utils文件中增加两个函数，一个是获取多页面路径作为entry文件的入口，另一个是生成页面多页面plugin的配置，废话不多说，上代码。</p><p>首先需要安装一个node模块<a href="https://www.npmjs.com/package/glob" target="_blank" rel="noopener">glob</a>，glob可以读取相应后缀名的文件，便于检索出需要的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev glob</span><br></pre></td></tr></table></figure></p><p>在utils.js中添加如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">const glob = require(&apos;glob&apos;)</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;)</span><br><span class="line"></span><br><span class="line">const PAGE_PATH = path.resolve(__dirname, &apos;../src/pages&apos;)</span><br><span class="line"></span><br><span class="line">// 多页面入口文件配置</span><br><span class="line">exports.entries = function () &#123;</span><br><span class="line">//  读取pages下的 页面名称文件下的后缀为js的文件</span><br><span class="line">  var entryFiles = glob.sync(PAGE_PATH + &apos;/*/*.js&apos;)</span><br><span class="line">  var map = &#123;&#125;</span><br><span class="line">  entryFiles.forEach((filePath) =&gt; &#123;</span><br><span class="line">    // 因为后缀为js的文件名在index，而我们想获取的是</span><br><span class="line">    var pathArry = filePath.split(&apos;/&apos;)</span><br><span class="line">    var filename = pathArry[pathArry.length - 2]</span><br><span class="line">    map[filename] = filePath</span><br><span class="line">  &#125;)</span><br><span class="line">  // 整理成文件名为Key，路径为value的Object对象</span><br><span class="line">  return map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多页面输出配置</span><br><span class="line">exports.htmlPlugin = function () &#123;</span><br><span class="line">  let entryHtml = glob.sync(PAGE_PATH + &apos;/*/*.ejs&apos;)</span><br><span class="line">  let arr = []</span><br><span class="line">  entryHtml.forEach((filePath) =&gt; &#123;</span><br><span class="line">    let pathArry = filePath.split(&apos;/&apos;)</span><br><span class="line">    // 获取页面名</span><br><span class="line">    let filename = pathArry[pathArry.length - 2]</span><br><span class="line"></span><br><span class="line">    let conf = &#123;</span><br><span class="line">      template: filePath,</span><br><span class="line">      filename: filename + &apos;.html&apos;,</span><br><span class="line">      chunks: [&apos;manifest&apos;, &apos;vendor&apos;, filename],</span><br><span class="line">      inject: true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (process.env.NODE_ENV === &apos;production&apos;) &#123;</span><br><span class="line">      conf = merge(conf, &#123;</span><br><span class="line">        minify: &#123;</span><br><span class="line">          removeComments: true,</span><br><span class="line">          collapseWhitespace: true,</span><br><span class="line">          removeAttributeQuotos: true</span><br><span class="line">        &#125;,</span><br><span class="line">        chunksSortMode: &apos;dependency&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push(new HtmlWebpackPlugin(conf))</span><br><span class="line">  &#125;)</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="修改webpack-base-conf-js"><a href="#修改webpack-base-conf-js" class="headerlink" title="修改webpack.base.conf.js"></a>修改webpack.base.conf.js</h3><p>代码如下，修改的部分只有入口文件的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const utils = require(&apos;./utils&apos;)</span><br><span class="line">const config = require(&apos;../config&apos;)</span><br><span class="line">const vueLoaderConfig = require(&apos;./vue-loader.conf&apos;)</span><br><span class="line"></span><br><span class="line">function resolve (dir) &#123;</span><br><span class="line">  return path.join(__dirname, &apos;..&apos;, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const createLintingRule = () =&gt; (&#123;</span><br><span class="line">  test: /\.(js|vue)$/,</span><br><span class="line">  loader: &apos;eslint-loader&apos;,</span><br><span class="line">  enforce: &apos;pre&apos;,</span><br><span class="line">  include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;)],</span><br><span class="line">  options: &#123;</span><br><span class="line">    formatter: require(&apos;eslint-friendly-formatter&apos;),</span><br><span class="line">    emitWarning: !config.dev.showEslintErrorsInOverlay</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  context: path.resolve(__dirname, &apos;../&apos;),</span><br><span class="line">  // 修改的部分=====开始</span><br><span class="line">  entry: utils.entries(),</span><br><span class="line">  // 修改的部分 === 结束</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: config.build.assetsRoot,</span><br><span class="line">    filename: &apos;[name].js&apos;,</span><br><span class="line">    publicPath: process.env.NODE_ENV === &apos;production&apos;</span><br><span class="line">      ? config.build.assetsPublicPath</span><br><span class="line">      : config.dev.assetsPublicPath</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,</span><br><span class="line">      &apos;@&apos;: resolve(&apos;src&apos;),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...(config.dev.useEslint ? [createLintingRule()] : []),</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.vue$/,</span><br><span class="line">        loader: &apos;vue-loader&apos;,</span><br><span class="line">        options: vueLoaderConfig</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        loader: &apos;babel-loader&apos;,</span><br><span class="line">        include: [resolve(&apos;src&apos;), resolve(&apos;test&apos;), resolve(&apos;node_modules/webpack-dev-server/client&apos;)]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 10000,</span><br><span class="line">          name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 10000,</span><br><span class="line">          name: utils.assetsPath(&apos;media/[name].[hash:7].[ext]&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,</span><br><span class="line">        loader: &apos;url-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: 10000,</span><br><span class="line">          name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  node: &#123;</span><br><span class="line">    // prevent webpack from injecting useless setImmediate polyfill because Vue</span><br><span class="line">    // source contains it (although only uses it if it&apos;s native).</span><br><span class="line">    setImmediate: false,</span><br><span class="line">    // prevent webpack from injecting mocks to Node native modules</span><br><span class="line">    // that does not make sense for the client</span><br><span class="line">    dgram: &apos;empty&apos;,</span><br><span class="line">    fs: &apos;empty&apos;,</span><br><span class="line">    net: &apos;empty&apos;,</span><br><span class="line">    tls: &apos;empty&apos;,</span><br><span class="line">    child_process: &apos;empty&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="webpack-dev-conf-js文件"><a href="#webpack-dev-conf-js文件" class="headerlink" title="webpack.dev.conf.js文件"></a>webpack.dev.conf.js文件</h3><p>完整代码比较多，只贴出了关键代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  new webpack.DefinePlugin(&#123;</span><br><span class="line">    &apos;process.env&apos;: require(&apos;../config/dev.env&apos;)</span><br><span class="line">  &#125;),</span><br><span class="line">  new webpack.HotModuleReplacementPlugin(),</span><br><span class="line">  new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.</span><br><span class="line">  new webpack.NoEmitOnErrorsPlugin(),</span><br><span class="line">  // https://github.com/ampedandwired/html-webpack-plugin</span><br><span class="line"></span><br><span class="line">  //-------- 注掉 配置中的 HtmlWebpackPlugin 这个插件---------------</span><br><span class="line"></span><br><span class="line"> // new HtmlWebpackPlugin(&#123;</span><br><span class="line">  //  filename: &apos;index.html&apos;,</span><br><span class="line">  //  template: &apos;index.html&apos;,</span><br><span class="line">  //  inject: true</span><br><span class="line"> // &#125;),</span><br><span class="line"></span><br><span class="line"> // ------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">  // copy custom static assets</span><br><span class="line">  new CopyWebpackPlugin([</span><br><span class="line">    &#123;</span><br><span class="line">      from: path.resolve(__dirname, &apos;../static&apos;),</span><br><span class="line">      to: config.dev.assetsSubDirectory,</span><br><span class="line">      ignore: [&apos;.*&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">  ])</span><br><span class="line"></span><br><span class="line">  // 添加----------utils中我们写的另一个函数utils.htmlPlugin-----------</span><br><span class="line">].concat(utils.htmlPlugin())</span><br><span class="line">// ---------------------------------------</span><br></pre></td></tr></table></figure></p><h3 id="webpack-prod-conf-js文件"><a href="#webpack-prod-conf-js文件" class="headerlink" title="webpack.prod.conf.js文件"></a>webpack.prod.conf.js文件</h3><p>生产环境的配置和开发环境一样，先注掉配置文件中的webpack插件HtmlWebpackPlugin的那段代码，然后在将utils中我们之前写的htmlplugin函数，生成的数组添加到plugin上。操作和上面webpack.dev.conf.js文件相同。</p><hr><p>好了一切配置完成，现在就可以实验一下了，执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></p><p>如果没什么问题的话就可以看到dist目录中生成，在文章开始我们设想的打包之后的页面结构。</p><p>GitHub项目地址：<a href="https://github.com/oneMoreTime1357/Vue-multiple-page" target="_blank" rel="noopener">Vue-multiple-page</a></p><p><strong>参考资料</strong>：</p><p>官网Entry Points介绍<br><a href="https://webpack.js.org/concepts/entry-points/#src/components/Sidebar/Sidebar.jsx" target="_blank" rel="noopener">https://webpack.js.org/concepts/entry-points/#src/components/Sidebar/Sidebar.jsx</a></p><p>HtmlWebpackPlugin<br><a href="https://github.com/jantimon/html-webpack-plugin" target="_blank" rel="noopener">https://github.com/jantimon/html-webpack-plugin</a></p><p>Vue多页面应用 blog<br><a href="https://segmentfault.com/a/1190000011265006" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011265006</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大部分使用Vue是构建单页面应用，但有时候我们也需要多页面应用，比如手机端的H5页面，可能这块需要一个H5页，另一块需要一个H5活动页，彼此相互独立，根本就没有什么关联，这时候还使用单页面应用增加了页面加载的速度，而且打包了一大堆和本页面无关的代码，增加了页面响应时间。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web分享到Twitter、Facebook、微信、微博</title>
    <link href="http://yikeshu.info/2018/06/10/Facebook%E3%80%81Twitter%E5%88%86%E4%BA%AB/"/>
    <id>http://yikeshu.info/2018/06/10/Facebook、Twitter分享/</id>
    <published>2018-06-10T11:27:49.190Z</published>
    <updated>2018-06-10T11:29:28.789Z</updated>
    
    <content type="html"><![CDATA[<p>分享是为了更好的传播，尤其是做业务平台网站的，传播是自然的事情，而且要和国际化接轨，就要能分享到Facebook、Twitter这样的网站，在中国这片土地上使用最多的就是微信了，所以微信也是一个很好的传播平台，但是自定义标题和缩略图在现在的微信是没有办法做到了。<br><a id="more"></a></p><h2 id="分享到微信"><a href="#分享到微信" class="headerlink" title="分享到微信"></a>分享到微信</h2><h4 id="微信内分享"><a href="#微信内分享" class="headerlink" title="微信内分享"></a>微信内分享</h4><p>不知有没有发现，自己的网站链接有时候分享到微信群中，发到朋友圈，右下角的缩略图没了。之前以为是没有集成JSSDK，但做了一个微信公众号的项目，集成了JSSDK，发现有的页面按照之前在body的最上方添加一张隐藏的默认图片形式也不行了，只有使用JSSDK中的分享方法，主动设置分享icon和标题才有作用。</p><p>网上查找才发现，微信6.5.5版本调整了分享规则，针对公众号的网页分享，必须接入微信认证公众号！<br><a href="https://mp.weixin.qq.com/s/hAdtKl2i4ilyo9HxT1kXyw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/hAdtKl2i4ilyo9HxT1kXyw</a></p><p>所以没有接入JSSDK的网站想要在微信中分享自定义标题和icon是没有希望了。<br>想要在微信中传播自定义标题和缩略图就要乖乖的集成JSSDK，按照规则分享吧:)</p><h4 id="从浏览器分享到微信"><a href="#从浏览器分享到微信" class="headerlink" title="从浏览器分享到微信"></a>从浏览器分享到微信</h4><p>在浏览器打开后，点击浏览器自带的分享图标，选择<strong>微信</strong>，这种方式获取缩略图的方法：<br>需要在head头部添加<a href="http://ogp.me/" target="_blank" rel="noopener">Open Graph Meta Data</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta property=&quot;og:type&quot; content=&quot;website&quot; /&gt;</span><br><span class="line">&lt;meta property=&quot;og:title&quot; content=&quot;页面标题&quot;&gt;</span><br><span class="line">&lt;meta property=&quot;og:description&quot; content=&quot;页面描述&quot;&gt;</span><br><span class="line">&lt;meta property=&quot;og:image&quot; content=&quot;http://www.example.com/img/thumbnail.png&quot;&gt;</span><br><span class="line">&lt;meta property=&quot;og:url&quot; content=&quot;http://www.example.com/&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>其中og:image是完整的URL，最好不要太大，毕竟是缩略图<br>亲测这种方式可以实现从手机浏览器分享到微信可定制缩略图和title。</p><p><strong>注意</strong><br>坑还在后面，如果分享的自定义的title中包含<strong>现金</strong>、<strong>提现</strong>、<strong>红包</strong>等这类关键字是分享不出去的，坑啊……所以我们改为繁体字之后就可以了，如果一定要用这类字就先用繁体字代替吧，要不然就换成别的吧。</p><h2 id="分享到-Facebook-amp-Twitter-amp-微博"><a href="#分享到-Facebook-amp-Twitter-amp-微博" class="headerlink" title="分享到 Facebook &amp; Twitter &amp; 微博"></a>分享到 Facebook &amp; Twitter &amp; 微博</h2><p>web页面想要分享到Facebook、Twitter和微博，简单的是需要在按钮写个a标签，将分享链接自定义，点击之后就可以跳到一个它们提供的外部分享页面，分享了。</p><h4 id="Weibo"><a href="#Weibo" class="headerlink" title="Weibo"></a>Weibo</h4><p>web微博分享直接在按钮上添加个a标签，直接调用微博开放出来的分享链接就可以了。标题和url都可以根据自己的需求填写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://service.weibo.com/share/share.php?appkey=&amp;title=填上你的标题&amp;url=http://example.com&amp;searchPic=false&amp;style=simple&quot; target=&quot;_blank&quot;&gt;Weibo&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><h4 id="Facebook"><a href="#Facebook" class="headerlink" title="Facebook"></a>Facebook</h4><p>web页面分享到Facebook也可以直接使用链接跳转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;https://www.facebook.com/sharer.php?title=填上你的标题&amp;u=http://example.com&quot; target=&quot;_blank&quot;&gt;Facebook&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>但是Facebook自定义title不管用，它自己有抓取目标页面代码的一套规则，对html中的<title>和<meta>标签进行分析。一般来说<title>会作为要分享的标题，<meta name="description" content="">会作为分享的正文。这是最基本的两个抓取点。<br><strong>注意</strong><br>抓取的内容是从服务端返回的html代码，由js操作后的html抓取不到。</title></title></p><p>所以想要Facebook分享能有图片和页面的标题，需要提前将meta中的og定义好，注意og:image中图片（完整url）的尺寸大小，最小不要小于200 x 200px，太小了也抓取不到。还有两种尺寸的图片大小，1200 x 630px 或者 600 x 315 根据自己的需要生成吧，而且图片需要在国外能很好的加载出来，我们使用的是七牛的链接，发现七牛的图片链接在国外支持的不太好，有时候会访问失败。<br><a href="https://developers.facebook.com/docs/sharing/best-practices#crawl" target="_blank" rel="noopener">Facebook share best practices</a></p><p>如果是简单的web分享，使用上面的分享链接就可以了，Facebook ID也没有必要去申请，如果想要在本页面中弹出弹窗分享链接，可以申请个Facebook app创建一个APP ID，要求不高一个链接完全就可以了。</p><p>没有抓取到设计的图片和标题，检测一下图片的链接和og中设置title和image对不对，记住js修改的抓取不到哦，其他的应该就没什么问题了</p><h4 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h4><p>web分享到Twitter，也可以直接使用分享链接，直接放到代码中就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;https://twitter.com/share?text=填上你的标题&amp;url=http://example.com&quot; target=&quot;_blank&quot;&gt;Twitter&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>如果想要使用Twitter分享带图片的链接，生成Twitter Cards的形式，需要在meta中添加图片的大小，<a href="https://developer.twitter.com/en/docs/tweets/optimize-with-cards/guides/getting-started" target="_blank" rel="noopener">官方文档Twitter cards</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;twitter:card&quot; content=&quot;summary&quot;&gt;&lt;/meta&gt;</span><br></pre></td></tr></table></figure></p><p>同样cards上的title、描述和图片也是抓取og中定义的title、description和image，提前在meta中定义好。</p><p><strong>注意</strong><br>Twitter也是只能抓取服务端返回的html，后来用js修改的meta抓取不到。</p><hr><p>Facebook分享调试工具<br><a href="https://developers.facebook.com/tools/debug/sharing/" target="_blank" rel="noopener">https://developers.facebook.com/tools/debug/sharing/</a></p><hr><p><strong>参考链接</strong><br><a href="https://doterlin.github.io/blog/2017/01/07/fb-share/" target="_blank" rel="noopener">web分享到Facebook、Twitter</a></p><p><a href="https://flniu.github.io/blog/2017/03/14/wechat-share-link-thumbnail/#%E6%96%B9%E6%B3%95%E4%B8%80%E5%9C%A8%E9%A1%B5%E9%9D%A2-body-%E6%9C%80%E4%B8%8A%E6%96%B9%E6%B7%BB%E5%8A%A0-300300-%E5%83%8F%E7%B4%A0%E7%9A%84-img" target="_blank" rel="noopener">微信分享没缩略图</a><br>注意：在body上添加图片已经失效。</p><p><a href="https://blog.csdn.net/qq_34543438/article/details/78254682" target="_blank" rel="noopener">微信分享没有缩略图</a></p><p>Facebook &amp; Twitter分享meta tag规则定义<br><a href="https://blog.kissmetrics.com/open-graph-meta-tags/" target="_blank" rel="noopener">What You Need to Know About Open Graph Meta Tag……</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享是为了更好的传播，尤其是做业务平台网站的，传播是自然的事情，而且要和国际化接轨，就要能分享到Facebook、Twitter这样的网站，在中国这片土地上使用最多的就是微信了，所以微信也是一个很好的传播平台，但是自定义标题和缩略图在现在的微信是没有办法做到了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《算法图解》 - 二分法查找</title>
    <link href="http://yikeshu.info/2018/04/26/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/"/>
    <id>http://yikeshu.info/2018/04/26/算法图解/</id>
    <published>2018-04-26T06:25:11.682Z</published>
    <updated>2018-04-26T12:45:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法</strong>是一组完成任务的指令。</p><p><strong>二分查找</strong>将查找的序列一分为二，从中间开始查找。</p><p>比如想在电话簿中查找以o开头的朋友的名字，你肯定不会从a开始查找，而是翻到中间从中间开始查找，像这种的就是二分查找。<br><a id="more"></a></p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><strong>二分查找</strong>是一种算法，其输入是一个有序的元素列表。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null。</p><p>使用二分查找每次能排除一半的数字。对于包含n个元素的列表，用二分查找最多需要log2n步，而简单查找最多需要n步。</p><p><strong>对数</strong><br>对数运算是幂运算的逆运算</p><p>问“将多少个10相乘的结果为100” 答案是两个 10 * 10 = 100<br>因此log10 100 = 1。</p><p>使用二分法查找时，最多需要检查log n个元素。如果列表包含8个元素，你最多需要检查3个元素，因为 log 8 = 3 （2^3 = 8）.如果列表包含1024个元素，你最多需要检查10个元素，因为 log 1024 = 10 （2^10 = 1024）</p><p><strong>注意：</strong>仅当列表是有序的时候，二分查找才管用。</p><p>二分法查找JS实现，查找元素的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let binarySearch = function (list, item) &#123;</span><br><span class="line">  // low height 表示要跟踪的最小和最大的元素位置索引</span><br><span class="line">  let low = 0;   </span><br><span class="line">  let height = list.length - 1;</span><br><span class="line"></span><br><span class="line">  while (low &lt;= height) &#123; // 要保证最小为1个数</span><br><span class="line">    // 取出元素中间位置的索引，向下取整</span><br><span class="line">    let midIndex = Math.floor((low + height) / 2);</span><br><span class="line">    let guss = list[midIndex];</span><br><span class="line">    if (guss === item) &#123; // 获取元素进行比较，相等则返回目标元素</span><br><span class="line">      return midIndex;</span><br><span class="line">    &#125; else if (guss &gt; item) &#123; // 猜大了，缩小范围</span><br><span class="line">      height = midIndex - 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      low = midIndex + 1; // 猜小了</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>二分法查找的运行时间是O(logn) 对数时间</li></ul><h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><p>仅知道算法需要多长时间才能运行完毕还不够，还需要知道运行时间如何随着列表增长而增加。</p><p>大O表示法指出了算法有多快。</p><p><strong>大O表示法让你能够比较操作数，它指出了算法运行时间的增速。</strong></p><p>未检查长度为n的列表，二分查找需要执行log n次操作。使用大O表示法，这个运行时间怎么表示呢？O(log n)</p><ul><li>大O表示法指出了最糟糕情况下的运行时间</li></ul><p>简单查找的运行时间为O(n)</p><p><strong>5种常用的大O运行时间</strong></p><ul><li>O(log n)也叫对数时间，这样的算法包括二分查找。</li><li>O(n),也叫线性时间，这样的算法包括简单查找。</li><li>O(n * log n)，这样的算法包括快速排序，一种速度较快的排序算法。</li><li>O(n^2)，这样的算法包括选择排序–一种速度较慢的排序算法。</li><li>O(n!)，这样的算法 一种非常慢的算法。</li></ul><p><strong>总结：</strong></p><ul><li>算法的速度指的并非时间，而是操作数的增速。</li><li>谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。</li><li>算法的运行时间用大O表示法表示</li><li>O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法&lt;/strong&gt;是一组完成任务的指令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二分查找&lt;/strong&gt;将查找的序列一分为二，从中间开始查找。&lt;/p&gt;
&lt;p&gt;比如想在电话簿中查找以o开头的朋友的名字，你肯定不会从a开始查找，而是翻到中间从中间开始查找，像这种的就是二分查找。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>添加Disqus评论</title>
    <link href="http://yikeshu.info/2018/04/18/hexo%E9%85%8D%E7%BD%AEDisqus/"/>
    <id>http://yikeshu.info/2018/04/18/hexo配置Disqus/</id>
    <published>2018-04-18T12:18:59.573Z</published>
    <updated>2018-04-18T14:22:39.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>首先第一步就是创建一个Disqus的账号，打开网站<a href="https://disqus.com/" target="_blank" rel="noopener">https://disqus.com/</a> 点击注册。使用邮箱注册但是还需要验证。<a id="more"></a></li></ul><p><img src="http://oybj22zxs.bkt.clouddn.com/login-disq.png" alt="login-disq"></p><ul><li>按着上面一步步走，下一步就到了一个选择项，咱们是想在hexo上安装Disqus所以，直接选择第二项“I want to install Disqus on my site”</li></ul><p><img src="http://oybj22zxs.bkt.clouddn.com/select-site.png" alt="select-site"></p><ul><li>然后就到了这一步，创建一个新的站点</li></ul><p><img src="http://oybj22zxs.bkt.clouddn.com/set-site.png" alt="set-site"></p><p><strong>注意：</strong>这个Website Name填写的是唯一ID，而且一经创建无法修改。所以要想好设置，免得以后还得修改。</p><ul><li>然后Next，就到了选择服务，一般的选择免费的就够用了，想扩大以后还可以扩充。</li></ul><p><img src="http://oybj22zxs.bkt.clouddn.com/select-rang.png" alt="select-rang"></p><ul><li>跟着步骤走，到下一步选择平台，因为我们是用Hexo，而Hexo不属于上面的任何一个平台，所以直接选择没有找到平台，选择通用代码安装就可以了。</li></ul><p><img src="http://oybj22zxs.bkt.clouddn.com/select-platform.png" alt="select-platfor"></p><ul><li>选择完成之后，这有两行script代码，将这个代码拷贝出来，找到自己的主题配置评论的位置，然后粘到下面就可以了。</li></ul><p><img src="http://oybj22zxs.bkt.clouddn.com/set-code.png" alt="set-code"></p><ul><li>然后到了最后一步，设置这个站点的名字，和Url，就是你博客的地址的位置。点击完成设置，大工告成。</li></ul><p><img src="http://oybj22zxs.bkt.clouddn.com/complete-site.png" alt="complete-site"></p><p>如果展示上还有问题，那就需要看看hexo主题中设置的代码是否和自己站点的ID相同。<br>比较简单，只要按照上面一步步去做就能创建自己的评论系统了。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;首先第一步就是创建一个Disqus的账号，打开网站&lt;a href=&quot;https://disqus.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://disqus.com/&lt;/a&gt; 点击注册。使用邮箱注册但是还需要验证。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>setTimeout &amp; setInterval</title>
    <link href="http://yikeshu.info/2018/04/14/setTimeout-setInterval/"/>
    <id>http://yikeshu.info/2018/04/14/setTimeout-setInterval/</id>
    <published>2018-04-14T10:46:15.744Z</published>
    <updated>2018-04-14T14:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。</p><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">    alert(&apos;hello word&apos;)</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure><p>上述代码设置了等待一秒之后弹出警告框。setTimeout有两个参数，第一个是传递一个函数，第二个是毫秒数，在等待设置的毫秒数之后执行函数的操作。<br><a id="more"></a><br>但是在经过该时间后不一定会执行指定的函数代码。<br>原因是：<strong>JavaScript是一个单线程解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个参数告诉JavaScript再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。</strong></p><p>在调用setTimeout之后，该方法会返回一个数值ID，表示超时调用。这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用<strong>clearTimeout</strong>方法并将ID作为参数传递给它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var timeoutId = setTimeout(function () &#123;</span><br><span class="line">    alert(&apos;hello world&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">clearTimeout(timeoutId)</span><br></pre></td></tr></table></figure></p><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h4><p>间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval(function () &#123;</span><br><span class="line">    alert(&apos;hello world&apos;)</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure></p><p>调用setInterval()方法同样会返回一个间歇调用ID，该ID可用于在将来某个时刻取消间歇调用。要取消间歇调用可以使用<strong>clearInterval()</strong>方法并传入相应的间歇调用ID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var max = 10</span><br><span class="line">var num = 0</span><br><span class="line">var intervalId = setInterval(function () &#123;</span><br><span class="line">    num++</span><br><span class="line">    if (num === max) &#123; // 当num达到最大值时取消间歇调用</span><br><span class="line">        clearInterval(intervalId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure></p><hr><h4 id="有趣的面试题"><a href="#有趣的面试题" class="headerlink" title="有趣的面试题"></a>有趣的面试题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;=5; i++) &#123;</span><br><span class="line">    setTimeout( function timer () &#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;, i * 1000);</span><br><span class="line">&#125;</span><br><span class="line">// 要求改动上述代码，使其依次输出1，2，3，4，5</span><br></pre></td></tr></table></figure><p>根据上面setTimeout的执行调用可知，JS是一个单线程解释器，一段时间只能执行一段代码，为了控制执行JS有自己的任务队列，这些任务会按照将它们添加到任务队列的顺序执行，而setTimeout中的时间参数是告诉JS多久之后将它添加到队列中。所以上面的setTimeout中要执行的函数，要等到for循环执行完成之后，再过一秒将setTimeout中的函数添加到任务队列中，然后执行。</p><p>直接执行上面的代码会每隔一秒钟输出一个6，因为到执行setTimeout中的函数时，i已经变成了6（因为循环里每次迭代同时共享着变量i，循环内部创建的函数全都保留了对相同变量的引用），所以会输出6。</p><p>要想实现不同的数字，就需要把每个定时器访问的变量独立起来，这就用到了JS中的闭包。</p><ul><li>使用闭包来解决 - <em>闭包是指有权访问另一个函数作用域中的变量的函数</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 在setTimeout外添加一个立即调用函数表达式，将变量i作为参数传入闭包中</span><br><span class="line">for (var i = 1; i &lt;=5; i++) &#123;</span><br><span class="line">    (function(value) &#123;</span><br><span class="line">            setTimeout( function timer () &#123;</span><br><span class="line">                console.log(i)</span><br><span class="line">            &#125;, i * 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    )(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在循环内部，立即调用函数（IIFE）为接受的每一个变量i都创建了一个副本并存储为变量value。这个变量的值就是响应迭代创建的函数所使用的值，因此调用每个函数都会像从0-9循环一样得到期望的值。</p><ul><li>使用块级作用域let来解决<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">    setTimeout( function timer () &#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;, i * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>每次循环的时候let声明都会创建一个新的变量i，并将其初始化为i的当前值，所以循环内部创建的每个函数都能得到属于它们自己的i的副本。</p><hr><p>参考链接<br><a href="https://segmentfault.com/a/1190000009017901" target="_blank" rel="noopener">setTimeout面试题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。&lt;/p&gt;
&lt;h4 id=&quot;setTimeout&quot;&gt;&lt;a href=&quot;#setTimeout&quot; class=&quot;headerlink&quot; title=&quot;setTimeout&quot;&gt;&lt;/a&gt;setTimeout&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;setTimeout(function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&amp;apos;hello word&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, 1000)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码设置了等待一秒之后弹出警告框。setTimeout有两个参数，第一个是传递一个函数，第二个是毫秒数，在等待设置的毫秒数之后执行函数的操作。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yikeshu.info/categories/JS/"/>
    
    
      <category term="JS" scheme="http://yikeshu.info/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>CSS垂直居中</title>
    <link href="http://yikeshu.info/2018/04/03/CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <id>http://yikeshu.info/2018/04/03/CSS垂直居中/</id>
    <published>2018-04-03T05:20:49.283Z</published>
    <updated>2018-10-17T06:44:06.072Z</updated>
    
    <content type="html"><![CDATA[<p>CSS垂直居中基本上经常需要用到的一个需求，而且面试的时候也有的公司会考察这个问题，但是需要手写出来，所以对于这个老生常谈的问题还是需要记住，下面就是我总结出了几种垂直居中的方法：<br><a id="more"></a></p><h4 id="基于绝对定位的方法"><a href="#基于绝对定位的方法" class="headerlink" title="基于绝对定位的方法"></a>基于绝对定位的方法</h4><p>这种方法采用了绝对定位的方法适用于，固定宽高的模块。废话不说上代码<br>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;center&quot;&gt;居中文本&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">.center &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">    -webkit-transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原理就是使用绝对定位相对于父元素，左边偏移50%，右边偏移50%，然后再使用<strong><a href="https://www.w3cplus.com/content/css3-transform" target="_blank" rel="noopener">transform</a></strong>中的translate进行位移，translate移动是根据元素中心作为参考值移动的，所以以元素中心为基点，再向左向上移动-50%，此元素就达到居中的效果了。</li></ul><h4 id="table垂直居中"><a href="#table垂直居中" class="headerlink" title="table垂直居中"></a>table垂直居中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;table style=&quot;width=100%&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;这是table垂直居中&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>如果担心语义上的不同，可以使用如下方式<br>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;table-style&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;table-cell&quot;&gt;table垂直居中&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.table-style &#123;</span><br><span class="line">    display: table;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.table-cell &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Flex解决方案"><a href="#使用Flex解决方案" class="headerlink" title="使用Flex解决方案"></a>使用Flex解决方案</h4><p>html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;center&quot;&gt;flex居中&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">    width：100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">    justify-content: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Flex中的<strong>align-items</strong>定义项目在交叉轴上如何对齐，<strong>center</strong>是交叉轴的中点对齐，而<strong>justify-content</strong>定义了项目在主轴上的对齐方式，<strong>center</strong>在主轴方向居中，两者组合就可以实现垂直居中的效果。</p><hr><p>这就是我总结的三种垂直居中的方法，如何还有更好的方法欢迎交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS垂直居中基本上经常需要用到的一个需求，而且面试的时候也有的公司会考察这个问题，但是需要手写出来，所以对于这个老生常谈的问题还是需要记住，下面就是我总结出了几种垂直居中的方法：&lt;br&gt;
    
    </summary>
    
      <category term="Web" scheme="http://yikeshu.info/categories/Web/"/>
    
    
      <category term="CSS" scheme="http://yikeshu.info/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Position fixed Inner content list 滚动卡顿</title>
    <link href="http://yikeshu.info/2018/01/29/position-fixed-content-scroll/"/>
    <id>http://yikeshu.info/2018/01/29/position-fixed-content-scroll/</id>
    <published>2018-01-29T11:09:26.135Z</published>
    <updated>2018-01-31T09:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做项目的过程中，总是会遇到要实现一个弹出视图，多数需求都是在弹出视图中添加一个滚动列表，使弹出视图撑满整个屏幕，并固定在屏幕上方，一般都会想到使用<code>position: fixed</code> 将top, left, right ,bottom 都设置为0，这样就能撑满整个屏幕，在当前窗口弹出一个固定位置的视图大小，示例如下代码<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">html, body &#123;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.model-fixed-view &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  margin: 30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在<code>.model-fixed-view</code>这个视图已经固定在屏幕上方距离边界30px的位置，那接下来需要在上面加载一个列表，并能滚动例如。<br><img src="http://oybj22zxs.bkt.clouddn.com/scroll-text.png" alt=""></p><p>在html中一般只要内部视图超出屏幕高度，就会自动滚动加载。如下设置一个视图高度很高的样式，来模拟滚动的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.content &#123;</span><br><span class="line">  background-color: blue;</span><br><span class="line">  height: 2000px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>样式展示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;model-fixed-view&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;content&quot;&gt;ddd&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>但是这样写之后会发现一个问题，内部视图虽然已将远远超出父视图的高度，但是内部视图不能滚动加载，即使能滚动加载，在手机上滑动滚动的时候依然很少卡顿，在试了各种办法之后，依然效果不好，网上搜集资料找到了如下解决办法。</p><h4 id="解决fixed-content滑动卡顿，不滑动的问题"><a href="#解决fixed-content滑动卡顿，不滑动的问题" class="headerlink" title="解决fixed content滑动卡顿，不滑动的问题"></a>解决fixed content滑动卡顿，不滑动的问题</h4><p>找了一些办法，只要在设置fixed父视图中添加如下的样式，就可以解决滑动卡顿，滑动不流畅的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.model-fixed-view &#123;</span><br><span class="line">  overflow-y: scroll;</span><br><span class="line">  -webkit-overflow-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考链接：<br><a href="https://css-tricks.com/forums/topic/prevent-body-scrolling-when-the-user-scrolls-on-fixed-position-div/" target="_blank" rel="noopener">https://css-tricks.com/forums/topic/prevent-body-scrolling-when-the-user-scrolls-on-fixed-position-div/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做项目的过程中，总是会遇到要实现一个弹出视图，多数需求都是在弹出视图中添加一个滚动列表，使弹出视图撑满整个屏幕，并固定在屏幕上方，一般都会想到使用&lt;code&gt;position: fixed&lt;/code&gt; 将top, left, right ,bottom 都设置为0，这样就能撑满整个屏幕，在当前窗口弹出一个固定位置的视图大小，示例如下代码&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yikeshu.info/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>Start 2018</title>
    <link href="http://yikeshu.info/2018/01/17/start2018/"/>
    <id>http://yikeshu.info/2018/01/17/start2018/</id>
    <published>2018-01-17T03:59:55.970Z</published>
    <updated>2018-01-17T07:10:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2018年1月17号，至今2018年已经过去半个月了。</p><p>就在昨天我找到了自己喜欢的博客主题，然后就迫不及待的把它安到我自己的博客上，并在此上面做了简单的修改，才成为现在的样子，真的很喜欢这个博客主题，越看越喜欢，现在就越来越想让自己的博客内容丰富起来，已经开始迫不及待的想写文章了，哈哈。<br><a id="more"></a><br>博客搭建到现在已经有一年多了，但上面的文章聊聊无几，写出来能读下去的内容也很少，不得不说我之前真的不会写文章。但自从在2017的下半年，我开始每天用文字记录自己的想法，脑子里想到什么就把它写出来，不知不觉已经记录到现在。而现在我才开始渐渐体会到这样做的好处，一能让自己的脑子更清晰，想到什么就写什么，有时候心烦意乱但写着写着脑子就很清晰了，二来锻炼了自己的文字表达能力，以前总是不会表达自己，而现在可以简单的用文字表达自己的想法了，虽然写的并不算好，但能表达出自己的想法也是不小的进步，要知道我之前根本不会表达自己的想法，太沉默了。</p><p>2018年，虽然现在还是和以前一样上班下班，每天还在为吃什么而发愁，但现在回首这十几天的生活给我的感觉是，过去的每一天都很充实。</p><p>要说2018年最大的改变就是，开始每天写效率手册，开始每天记录自己的生活。效率手册是潇洒姐发明的，手册每一页都是已经排版好的样式，每天只要在上面写就可以了。早晨起床之后的第一件事情就是写效率手册，计划好这一天要做的事情，晚上睡前的最后一件事就是在效率手册记下这一天的收获，自己做了哪些事情。在每月的开始都有一整页的空白，可以写下自己的月计划。本子的最后一页是用来写自己的一生计划，一生计划听着好像很长似的，但它可以拆成两年三年的计划，写最近两年或者三年、五年都可以，我是计划不了那么长远的未来，现在写的是未来两年的计划。这个我也想了好久，直到去写下来，才知道自己从来都没想过，以后的生活会是什么样，自己要成为什么样的人，在没有这个计划之前，一直是船到桥头自然直，虽然这样也可以活着，但自从开始了这个计划之后，生活有了目标，就少了很多的无病呻吟和烦恼，为了自己的计划和未来美好的生活，心中有了目标，走的也会更坚毅，现在的每一天都会为达到自己的目标而更努力，每一天都量化了，可以很直观的看到自己进步了多少，做了多少努力，看了多少书。有了这个效率手册确实对我的帮助很大，清楚了自己做了些什么，才发现自己一直都很努力，积极乐观。现在只过了短短的半个月时间，每天写效率手册成了我最快乐的事情，每一天都记录自己的生活，这样到年底就能有效的评估自己和梦想之间的距离，看到自己每一天走过的路都是那么充实和快乐，就像手册上第一句话写的那样 —— —— “时间看得见”</p><p>2018年我还坚持早起，现在是冬季，计划是每天早晨6点起床，虽然不是很早，但相比于之前八点起床还是多了两个小时的时间，去年也计划过早起，但往往坚持两三天就放弃了，而现在坚持早起已经十五天了，偶尔一两次懒床起不来，我也不再像之前那样懊恼自己起不来了，在了解了自己为什么起不来的原因之后，都能很快的原谅自己，下次再做好就是了。每一天都不同，总会有特殊的情况扰乱计划，而我也不像之前懊恼自己的计划失败，而在心里责怪自己。就因为某一天的失败而让整个早起计划失败掉，是得不偿失的，这一次没做好，争取下一次做到更好就是了，这是一项长期计划，一年三百六十五天不可能做到每一天都完美，关键是接受自己的不完美，明白什么才是对自己最重要的。</p><p>这是一个很好的开始，2018一定很精彩，一起期待吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2018年1月17号，至今2018年已经过去半个月了。&lt;/p&gt;
&lt;p&gt;就在昨天我找到了自己喜欢的博客主题，然后就迫不及待的把它安到我自己的博客上，并在此上面做了简单的修改，才成为现在的样子，真的很喜欢这个博客主题，越看越喜欢，现在就越来越想让自己的博客内容丰富起来，已经开始迫不及待的想写文章了，哈哈。&lt;br&gt;
    
    </summary>
    
      <category term="Thking" scheme="http://yikeshu.info/categories/Thking/"/>
    
    
  </entry>
  
  <entry>
    <title>理解JavaScript中的闭包</title>
    <link href="http://yikeshu.info/2017/08/11/%5B%E8%AF%91%5D%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <id>http://yikeshu.info/2017/08/11/[译]理解JavaScript中的闭包/</id>
    <published>2017-08-11T12:27:57.000Z</published>
    <updated>2018-04-26T12:37:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>闭包并不复杂。学习和理解闭包的基础知识仅仅只需要10分钟。</p><h4 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h4><p>闭包是JavaScript的一部分，每个工程师都应该知道和理解闭包。今天的文章只是撇开闭包的表面，但是将会给你一个很好的思想，关于什么是闭包和它在JavaScript中是如何运行的。好了，接下来我们开始吧。<br><a id="more"></a><br>我们先从书本中闭包的定义开始。</p><h4 id="定义1"><a href="#定义1" class="headerlink" title="定义1"></a>定义1</h4><blockquote><p>闭包是一个能访问父作用域的函数，即使此作用域关闭了。</p></blockquote><h4 id="定义2"><a href="#定义2" class="headerlink" title="定义2"></a>定义2</h4><blockquote><p>闭包是一个函数和该函数被声明的词汇环境的组合。</p></blockquote><p>很好，但是这些真正的意思是什么？</p><p>首先你需要理解在JavaScript中的<strong>作用域</strong>，作用域实质上是变量在JavaScript中的生命周期。因此，当一个变量定义了一个大的作用域，这个变量会存活多久，那个方法在你的程序中会访问到它。</p><p>让我们看一个例子。</p><p>当你在JavaScript中创建一个函数，它可以访问创建在这个函数里面和外面的变量。</p><p>变量创建在一个函数中也定义了这个变量。一个局部变量只能在这个被定义的函数里面访问到。在下面这个例子中，你将会看到如果我们尝试在这个函数外面打印<code>words</code>，它会输出错误信息。这是因为<code>words</code>是一个内部作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak () &#123;</span><br><span class="line">  var words = &apos;hi&apos;;</span><br><span class="line">  console.log(words);</span><br><span class="line">&#125;</span><br><span class="line">speak(); // hi</span><br><span class="line">console.log(words); // undefined</span><br></pre></td></tr></table></figure><p>和上一个例子不同，这次我们定义这个words 为全局作用域。<br>意思是说我们可以在任何函数中访问这个变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 将变量放到函数的外面</span><br><span class="line">// words 现在是个全局变量</span><br><span class="line">var words = &apos;hi&apos;;</span><br><span class="line">function speak()&#123; </span><br><span class="line">  console.log(words);</span><br><span class="line">&#125;</span><br><span class="line">speak(); // &apos;hi&apos; </span><br><span class="line">console.log(words); // &apos;hi&apos;</span><br></pre></td></tr></table></figure><h4 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h4><p>我们将一个函数放到另一个函数里面会发生什么？我想你跟着操作下面的例子，因为这个会很有趣！</p><p>如果你使用谷歌浏览器，打开你的开发工具调试模式：<br>[Windows]：Ctrl + Shift + J<br>[MAC]：Cmd + Opt + J</p><p>Cool，现在拷贝下面的代码然后粘贴到你的控制台中。我们现在做的是创建一个名字为<code>speak</code>的函数。<code>speak</code>返回一个名称为<code>logIt</code>的函数。最终<code>logIt</code>在控制台中打印log值为<code>words</code>，在这个实例要实现在控制台中输出 <code>‘hi’</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">  return function logIt() &#123;</span><br><span class="line">    var words = &apos;hi&apos;;</span><br><span class="line">    console.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你拷贝到这段代码到你的控制台中，我们将要创建一个变量，然后将speak函数赋值给它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sayHello = speak();</span><br></pre></td></tr></table></figure></p><p>现在我们可以看见这个变量<code>sayHello</code> 调用了之后，没有执行内部函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sayHello;</span><br><span class="line">//  function logIt() &#123;</span><br><span class="line">//    var words = &apos;hi&apos;;</span><br><span class="line">//    console.log(words);</span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure></p><p>如上打印的结果，<code>sayHello</code> 打印的是我们return的内部函数，也就是说，如果我们执行<code>sayHello()</code>在控制台中，它将会唤起执行<code>logIt()</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sayHello();</span><br><span class="line">// &apos;hi&apos;</span><br></pre></td></tr></table></figure></p><p>它奏效了，但是并没有任何特别。让我们移除一行代码看看什么发生了改变。请看下面的示例。我们将清楚定义的变量<code>words</code>移到<code>speak()</code>函数的里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">  var words = &apos;hi&apos;;</span><br><span class="line">  return function logIt() &#123;</span><br><span class="line">    console.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>像之前的操作，让我们定义一个变量并将speak函数赋值给它:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sayHello = speak();</span><br></pre></td></tr></table></figure></p><p>现在我们看看我们的 sayHello变量会输出什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHello</span><br><span class="line">//  function logIt() &#123;</span><br><span class="line">//    console.log(words);</span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure></p><p>哦，这里没有<code>words</code> 变量的定义，那么发生了什么当我们执行这个函数的时候？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sayHello();</span><br><span class="line">// &apos;hi&apos;</span><br></pre></td></tr></table></figure></p><p>它仍然起作用了！这是因为你刚刚体验了闭包的影响。</p><p>是否有点疑惑？没关系，回想下我们的闭包的定义：</p><blockquote><p>闭包是一个能访问父作用域的函数，即使此作用域关闭了。</p></blockquote><p>在这个例子中我们的<code>speak()</code>函数作用域关闭了。这意味着 <code>var words = &#39;hi&#39;</code> 应该消失了。然而，在JS中我们有一个名称将这种现象叫做闭包：<strong><em>我们的内部函数保持对其创建的范围的引用</em></strong>。这就允许<code>logIt()</code>函数仍然可以访问<code>words</code>这个变量——即使<code>speak()</code>这个函数作用域关闭了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">  var words = &apos;hi&apos;;</span><br><span class="line">  return function logIt() &#123;</span><br><span class="line">    console.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>重要提示，在JavaScript中每个函数都有一个闭包。你不需要你去解释闭包在函数中是怎么运行的，它仅仅只是JavaScript的一部分。</p></blockquote><h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p>让我们查看另一个例子。这个例子有点复杂，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function name(n) &#123;</span><br><span class="line">  return function(a) &#123;</span><br><span class="line">    return `$&#123;n&#125; likes $&#123;a&#125;`;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们定义了一个名字为<code>name</code> 的函数可以传递一个参数，返回一个匿名函数，可以传递一个不同的参数，内部函数返回一个字符串。</p><p>我们用<code>name</code>函数创建两个变量。一个我们给name函数传递 John，另一个传 Cindy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var j = name(&apos;John&apos;);</span><br><span class="line">var c = name(&apos;Cindy&apos;);</span><br></pre></td></tr></table></figure></p><p>让我们看看<code>j</code>现在能打印什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j;</span><br><span class="line">//  function (a) &#123;</span><br><span class="line">//    return `$&#123;n&#125; likes $&#123;a&#125;`;</span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure></p><p>所以根据之前示例我们知道这是因为闭包，这个函数应该仍然可以访问<code>n</code>的变量通过父作用域。我们所能做的是把<code>a</code>传递过去，在执行函数的时候。</p><p>让我们试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j(&apos;dogs&apos;);  // &apos;John likes dogs&apos;</span><br><span class="line">c(&apos;cats&apos;);  // &apos;Cindy likes cats&apos;</span><br></pre></td></tr></table></figure></p><p>成功了！因为闭包我们才能从之前关闭的作用域引用变量成功的执行我们的函数。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望你现在可以理解基本的闭包在JavaScript和它是如何运行的！这虽然只是冰山一角，但明白了基础知识才能学习和练习更复杂的闭包。</p><hr><p>翻译原文链接：<a href="https://codeburst.io/understand-closures-in-javascript-d07852fa51e7" target="_blank" rel="noopener">https://codeburst.io/understand-closures-in-javascript-d07852fa51e7</a><br>翻译中有疏漏的地方，欢迎指正。</p><p>校对：蹦蹦</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包并不复杂。学习和理解闭包的基础知识仅仅只需要10分钟。&lt;/p&gt;
&lt;h4 id=&quot;什么是闭包？&quot;&gt;&lt;a href=&quot;#什么是闭包？&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包？&quot;&gt;&lt;/a&gt;什么是闭包？&lt;/h4&gt;&lt;p&gt;闭包是JavaScript的一部分，每个工程师都应该知道和理解闭包。今天的文章只是撇开闭包的表面，但是将会给你一个很好的思想，关于什么是闭包和它在JavaScript中是如何运行的。好了，接下来我们开始吧。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yikeshu.info/categories/JS/"/>
    
    
      <category term="JS" scheme="http://yikeshu.info/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>解决Chrome不能播放mp4视频的问题和HLS视频播放</title>
    <link href="http://yikeshu.info/2017/08/11/%E8%A7%A3%E5%86%B3Chrome%E4%B8%8D%E8%83%BD%E6%92%AD%E6%94%BEmp4%E8%A7%86%E9%A2%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8CHLS%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/"/>
    <id>http://yikeshu.info/2017/08/11/解决Chrome不能播放mp4视频的问题和HLS视频播放/</id>
    <published>2017-08-11T12:25:12.000Z</published>
    <updated>2017-08-11T12:57:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在面临一个问题chrome中播放后缀名为.mp4的视频文件只有声音播放不出视频画面，上网查了一下才知道，MP4视频不是说后缀名以.mp4结尾的就是MP4视频，mp4视频还包括不同的编码格式，还有不同的扩展名，都可以统一定义成MP4文件，而chrome只支持标准的H.264方式的编码，所以如果视频编码格式不对，chrome还是加载不出来的。<br><a id="more"></a><br>想要查看视频的编码格式，最简单查看视频信息的方式是，在文件中选中视频点击右键查看简介或者详细信息，下面有一个栏信息是编解码器：标准的编码格式是H.264，如果不是这种格式，那很抱歉chrome加载不出来是正常的。</p><p>为什么chrome只支持H264这种格式呢，而不支持所有的视频编码格式？查了一下大概是说，绝大部分的视频编码格式都是要付专利费的，Google已经买了H264编码格式，所以其他的就不买了，Firefox没有Google那么有钱不愿意买。不过它使用Flash，绝大部分的视频格式基本上可以通过Flash播放。</p><p>而我司解决办法是，将MP4视频文件转码统一转成hls格式编码的视频，这种格式的视频后缀名是以.m3u8结尾的。</p><h4 id="什么是HLS？"><a href="#什么是HLS？" class="headerlink" title="什么是HLS？"></a>什么是HLS？</h4><p>HTTP Live Streaming（简称HLS）是一个基于HTTP的视频流协议，由苹果公司实现，</p><p>HTTP流媒体直播(HLS)是一种基于HTTP的媒体流媒体通信协议，由苹果公司实施，作为QuickTime、Safari、OS X和iOS软件的一部分。它的工作原理是将整个流程分解成一个小的基于http的文件下载序列，每个下载都加载了一个完整的潜在无界传输流的一小块。</p><h4 id="什么m3u8"><a href="#什么m3u8" class="headerlink" title="什么m3u8"></a>什么m3u8</h4><p>先说说M3U，M3U是一种播放多媒体列表的文件格式，它的设计初衷是为了播放音频文件比如MP3,但是越来越多的软件现在用来播放视频文件列表，M3U也是可以指定在线留媒体音频源。很多播放器和软件都支持M3U文件格式。</p><p>M3U8是Unicode版本的M3U，用UTF-8编码。’M3U’和M3U8‘文件都是苹果公司使用的HTTP Live Streaming格式的基础，这种格式可以在iPhone和Macbook等设备播放。</p><h4 id="平台支持情况"><a href="#平台支持情况" class="headerlink" title="平台支持情况"></a>平台支持情况</h4><p>苹果的产品都能很好的支持，iPhone、Safari，但是在chrome和Firefox还有一些其他未知的浏览器不支持播放这种视频格式。</p><p>So，想要播放这种格式的视频，前端这块还要做一层处理，不过不用担心，已经有人帮我们造好轮子了，Github上有很好的库可以支持这种视频格式的播放，<a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">VideoJs</a>,<a href="https://github.com/videojs/videojs-contrib-hls" target="_blank" rel="noopener">videojs-contrib-hls</a><br>集成起来也非常的简单，github上都给了一些示例。</p><h4 id="快速集成开发"><a href="#快速集成开发" class="headerlink" title="快速集成开发"></a>快速集成开发</h4><p>在<code>head</code>头中引入如下的CDN，需要引入videojs的样式，是为了使用播放器的样式，要不然播放器会很难看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=&quot;//vjs.zencdn.net/5.19/video-js.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;script src=&quot;//vjs.zencdn.net/5.19/video.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.8.3/videojs-contrib-hls.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;video id=&quot;video-play&quot; class=&quot;video-js vjs-default-skin&quot;</span><br><span class="line">      style=&quot;width: 600px; height: 400px;&quot;</span><br><span class="line">      playsinline webkit-playsinline</span><br><span class="line">      controls preload=&quot;auto&quot;</span><br><span class="line">      x-webkit-airplay=&quot;true&quot; controlsList=&quot;nodownload&quot; oncontextmenu=&quot;return false&quot;&gt;</span><br><span class="line">      &lt;source src=&quot;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt;</span><br><span class="line">    &lt;/video&gt;</span><br><span class="line">    &lt;button&gt;播放&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var el = document.getElementById(&quot;play-btn&quot;)</span><br><span class="line">    el.addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">        window.videojs(&apos;video-play&apos;, &#123;&#125;, function onPlayerReady () &#123;</span><br><span class="line">         this.play()</span><br><span class="line">         this.on(&apos;ended&apos;, function () &#123;</span><br><span class="line">             console.log(&apos;ended, video js&apos;)</span><br><span class="line">         &#125;)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h4><ul><li>MP4视频编码格式有哪几种<br>MP4视频格式包括：MPEG-4 SP(Simple Profile/简单类)/ASP(Advanced Simple Profile/高级简单类)：xvid, divx5, 3ivx,ffmpeg/ffdshow, NeroDigital ASP…及MPEG-4 AVC/H.264：x264, NeroDigital AVC, Apple…还有MPEG-2, MPEG-1（不含Divx3/M$ MPEG4, WM9, RV9或VP6）.-</li></ul><hr><p>参考链接：<br>Mp4编码全介绍：<a href="https://my.oschina.net/alphajay/blog/4276" target="_blank" rel="noopener">https://my.oschina.net/alphajay/blog/4276</a><br><a href="http://www.jianshu.com/p/52c569efbfc0" target="_blank" rel="noopener">http://www.jianshu.com/p/52c569efbfc0</a><br><a href="https://imququ.com/post/html5-live-player-1.html" target="_blank" rel="noopener">https://imququ.com/post/html5-live-player-1.html</a><br><a href="http://yanhaijing.com/html/2016/03/12/html5-video/" target="_blank" rel="noopener">http://yanhaijing.com/html/2016/03/12/html5-video/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在面临一个问题chrome中播放后缀名为.mp4的视频文件只有声音播放不出视频画面，上网查了一下才知道，MP4视频不是说后缀名以.mp4结尾的就是MP4视频，mp4视频还包括不同的编码格式，还有不同的扩展名，都可以统一定义成MP4文件，而chrome只支持标准的H.264方式的编码，所以如果视频编码格式不对，chrome还是加载不出来的。&lt;br&gt;
    
    </summary>
    
      <category term="WEB" scheme="http://yikeshu.info/categories/WEB/"/>
    
    
  </entry>
  
  <entry>
    <title>职场主动</title>
    <link href="http://yikeshu.info/2017/07/01/jobInitiative/"/>
    <id>http://yikeshu.info/2017/07/01/jobInitiative/</id>
    <published>2017-07-01T14:24:49.000Z</published>
    <updated>2018-01-17T03:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近喜欢看美国的一个真人秀节目—《学徒》，《学徒》是美国全国广播公司出品的一档职场创业型真人秀节目，这档节目的制作人是纽约的地产大亨唐纳德•特朗普（DonaldTrump）也就是现在的美国总统，他从全美21万多志愿者中选择16名学徒候选人加入比赛，这些被选拔出的选手们则要为了获得特朗普旗下的一个商业项目的经营机会而展开竞争。这个节目04年的时候开始播出，第一季一播出就风靡了全美国，连续四个月位居收视冠军宝座，平均家庭收视数位2070万，最高家庭收视数达4010万，成为五年来18——49岁成年任收视率最高的节目。我也是出于对特朗普的好奇，才开始看这期节目。<br><a id="more"></a><br>这两天刚看了第二季的第一集，所有征集来的参赛者将面临第一次竞争，首先将男生和女生各分成一组，两组展开竞争，这一次稍有点不同，按照男女分好组之后，要求男生组选出一个人去当女生队的队长，女生队选出一个人去当男生队的队长，说实话选出一个人比较难，去到任何一队都会很艰难，同性别的人很好交流，首先性别相同就很容易找到共同话题，而在当时的环境下，大家相处紧紧只有几个小时，要选出一个人去当他们的队长，还要去管理他们，如果我是身处在女性团队中的一个人，我是不愿意站出来说，我去他们组，真的这很艰难。但他们但凡被挑选出来一定有很强的能力，也是一群聪明人，商讨了一下，每一队都有人主动站出来，主动去担当其他队的队长，这是一个好机会，也是一个不小的挑战，如果失败就会面临被开除的风险。</p><p>他们这次执行的任务是，在玩具公司，为他们提供各种资源，各设计一款玩具，最后由专业人士评选出谁更受欢迎，受欢迎的那组获胜。整个设计过程不再细说了，只说我印象深刻的一点，其实也是我最关注的一点就是，其中一个团队失败了，在会议室见川普的那一刻，决定开除谁的那一刻。</p><p>这一集男生队失败了，在会议室里川普问在场的队员，觉得谁做的比较差，如果开除掉一个人你会开除谁，大家说的最多的就是罗杰，觉的他没有为整个团队做多大的贡献，而问罗杰：“你为什么没有为团队贡献”，他说是因为队长没有为他分配任务。罗杰是个典型的被动型人才，如果队长没有给他分配任务，他就觉得这个事情无从下手，本来面对一个大家不熟悉的玩具行业，大家也是摸着石头过河，各尽其能，而队长其实也没有将任务分配给各个人，说你要做什么，你去做什么，大家都做什么，相处的时间很短暂，大家互相了解的都不够，作为一个管理人员，是不可能分工明细，做到每个人都分配到任务。在这种情况下，就应该更主动一点，提出自己的想法，尽自己的一份力，而不是要让别人告诉你要做什么，不要做什么。罗杰肯定是一个好员工，但他缺少主动性，总是要让别人告诉你，你要去做什么，这样就会让机会白白的溜走。最后川普终于对他说出了那句话：“You are fired!”</p><p>职场中要想提高自己，是最不能缺少主动性的场所，反思一下我在工作中也是极度缺乏主动性的一个人，在工作中比如说有什么需求，就做这个需求，做完了就完了，明知道自己写的代码还有很多优化的空间，但就是不愿意主动提出来去修改，最明显的一个例子是，现在有个需求，只是修改一个小问题，已经提出来了，我当时也没有什么要紧的事，而我的另一个同事也在忙一些手头上不紧急的事情，但总是在我犹豫要不要做接这个需求的时候，他总是很主动的说交给我吧，每当线上出现问题的时候，他总是第一个出来询问现象，找到问题然后解决掉，年纪虽然不大，初入职场不久，看这势头以后前途无量啊。现在整个团队都很信任他，我虽然工作时间比较长了，但做什么事缺乏主动性，比较犹豫，一直把自己当成一个打工仔来思考问题，组长分配你什么任务就做什么，超过自己的需求范围一概不管，我这种虽然能把手头上的事情做好，但也仅限手头上的事而已，要想有所提升，在团队中提高自己的能力和信任感，还需要更主动的多做一些事情，多承担一些责任，做的越多对业务越熟练也就能越快的解决问题。</p><p>虽然这个节目只是为了赚钱、为特朗普选拔人才，但可以看到真实的商场和职场人的真实状态，从中学习到的职场思维，和如何在一群比你更聪明的人中脱颖而出，面对机会的时候，紧紧的抓住并主动出击，机会并不会求着你让你收下它，如果不争取它就会从你身边溜走。我相对来说面对职场这种丛林法则，自己的经验还是偏少，处理不好人际关系，缺少沟通交流的经验，还停留在学生思维，有人给你留作业，就认真完成，然后交作业。但在工作中不可能事无巨细的任何事情都给你安排好了，业务很紧急任务很多的时候，没有人顾得上你，先将自己该做的事情做好，然后更主动一点，才能在职场上有所成长晋升。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近喜欢看美国的一个真人秀节目—《学徒》，《学徒》是美国全国广播公司出品的一档职场创业型真人秀节目，这档节目的制作人是纽约的地产大亨唐纳德•特朗普（DonaldTrump）也就是现在的美国总统，他从全美21万多志愿者中选择16名学徒候选人加入比赛，这些被选拔出的选手们则要为了获得特朗普旗下的一个商业项目的经营机会而展开竞争。这个节目04年的时候开始播出，第一季一播出就风靡了全美国，连续四个月位居收视冠军宝座，平均家庭收视数位2070万，最高家庭收视数达4010万，成为五年来18——49岁成年任收视率最高的节目。我也是出于对特朗普的好奇，才开始看这期节目。&lt;br&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://yikeshu.info/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>小白健身第一周</title>
    <link href="http://yikeshu.info/2017/03/05/%E5%B0%8F%E7%99%BD%E5%81%A5%E8%BA%AB%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
    <id>http://yikeshu.info/2017/03/05/小白健身第一周/</id>
    <published>2017-03-05T10:49:31.000Z</published>
    <updated>2018-01-17T07:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>三月不减肥，五月徒伤悲。夏天来了，开始甩掉身上多余的赘肉，减肥！减肥！。正好附近有个健身房，办了张健身卡开始我的健身甩脂运动吧！<br><a id="more"></a></p><h4 id="制定健身计划"><a href="#制定健身计划" class="headerlink" title="制定健身计划"></a>制定健身计划</h4><p>对于小白的我第一次去健身房看到那么多器械完全是一脸懵逼的状态，到底要从哪里开始呢，这个器械要怎么操作锻炼的部位是哪里呢，完全一脸懵逼什么都不懂。没办法没钱请私教只能自己从网上找资料做笔记，根据自己的时间来安排制定健身计划。keep上有一个健身房入门女生版，看了几遍视频决定就先从这些简单的固定器械开始练习吧。</p><p>一周七天计划最少最少要去锻炼三次，本来计划是一三五、六日再去一天，这样就能有四天的锻炼时间，但是星期一第一天就没有实现。星期一按照平常的下班时间是六点四十左右，这样我到家的时间就是7点左右，这时再去健身房还不算太晚，然后再锻炼一个半小时大概八点半，就可以回家了。但没想到的是忘记考虑加班了，那天一直到加到七点多才下班，然后匆匆忙忙的找小黄车，找到好几个都是坏的没法骑了，我只好快步走回去了，到家大概7点四十左右，瞬间不想去健身房了，头也很痛。在多次斗争过后，还是懒癌细胞胜利了，放弃了去健身房，决定在家跳会HIIT，这也算运动了。最后计划调整为每周二四六必须去不得有任何的商量。周二依然加班到七点才走，但不能给自己任何的狡辩了，就算八九点了也要去健身房锻炼，不管锻炼了多久只要去了就可以，先养成去健身房锻炼身体的习惯，不能让自己那么胆怯害怕去健身房。</p><h4 id="健身房锻炼的体验"><a href="#健身房锻炼的体验" class="headerlink" title="健身房锻炼的体验"></a>健身房锻炼的体验</h4><p>总的来说，每次决定去的时候很纠结很艰难，像两方军队在打仗谁胜利了就听谁的。后来我不想思考到底是去还是不去了，既然计划了时间和地点只管换上运动鞋运动服去就好了，不要多想。这个星期还是按照自己原先调整规划好的时间去的，周二周四周六这三天，第一次只骑了20分钟的单车，第二次玩了几个简单的器械锻炼腿部的背部胸部之后再跑了30分钟，整个流程走下来已经很累了。刚开始主要是适应性训练，熟悉器械和健身房周围的环境，我不想刚开始就让自己以后再也不想去了。周六晚上去的时候人很少正好前两天一起聊天的一个教练有空，他看见我在练说要指导指导我的动作，就这样练了几组加了重量，这次练的时候比前两次都重，所以练的时候更吃力，还经过了专业的指导，动作也标准了些，所以练的更到位，身体并没有不适的感觉反而更舒服了，然后去做了半个小时的有氧运动，最后拉伸身体，锻炼完成，这个星期的任务就结束了。这三次的锻炼一次比一次的训练增强，我的运动能力也慢慢的提高了，身体好像被唤醒了一样，以前总是感觉昏昏沉沉的做什么都没有精神，自从开始锻炼以后整个人都发生了变化，精力更充沛了，也没有那种总睡不够的感觉了。工作也能更好的应对，虽然每次只花了一个半小时的时间，但我个人的精神状态，做事的效率都更好的提高了。每次锻炼完成之后虽然很累，但心情是愉悦的，也能体会到运动的乐趣。为了更美好的自己，加油加油！</p><h4 id="这几天的心得"><a href="#这几天的心得" class="headerlink" title="这几天的心得"></a>这几天的心得</h4><ul><li><p>记住当你计划好做一件事情的时候，不可能永远那么顺利，总会有突发状况等着你，延误了执行的时间，但不要心烦意乱，重要的是能在突发状况下依然坚持去执行。</p></li><li><p>不是说办了张健身卡身上的肉就能自然而然的掉下去，还要自己主动的去健身房锻炼，利用哪里的设备科学的锻炼自己的身体。没钱请私教就从网上学习，也要根据自己的身体条件选择合适的锻炼方式。好的身材都是靠练出来的，不断的锻炼才能达到目标。</p></li><li><p>我知道坚持锻炼很难，但当你把时间地点都想好以后，只管按照计划做就好了，什么都不要多想。像我计划下班之前在公司喝一杯酸奶或者一杯燕麦，这样晚餐解决了，下班回到家之后换好运动服直接去健身房，去到之后先热身然后练器械做几组，之后做有氧40分钟。这是我的计划，在脑海中模拟了几遍情景，每次时间到了潜意识就会知道该做什么了，直接做就好了不要多想。</p></li></ul><p>加油！科学的锻炼方法加上健康的饮食，就算达不到火辣的身材，也能收获健康的身体。健身第一周，感觉还不错，不得不鼓励鼓励自己做的很好，Good Job！O(∩_∩)O哈哈~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三月不减肥，五月徒伤悲。夏天来了，开始甩掉身上多余的赘肉，减肥！减肥！。正好附近有个健身房，办了张健身卡开始我的健身甩脂运动吧！&lt;br&gt;
    
    </summary>
    
      <category term="Fitness" scheme="http://yikeshu.info/categories/Fitness/"/>
    
    
  </entry>
  
  <entry>
    <title>oneDay</title>
    <link href="http://yikeshu.info/2017/02/18/oneDay/"/>
    <id>http://yikeshu.info/2017/02/18/oneDay/</id>
    <published>2017-02-18T09:56:16.000Z</published>
    <updated>2018-01-17T07:20:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 一日就是一生<br>                 —–（日）酒井雄哉</p><p>修行的每天早上，我都穿着草鞋出去。上山10公里之后，接着走10公里较平坦的路，最后是10公里的下坡路，如此这般每天重复。结束一天的登山行程后，草鞋往往变形、穿烂，隔天得穿上新鞋才行。<br>     日复一日地不断重复。有一天，我发现草鞋就像我自己。当脱掉草鞋的那一刻，今天的自己既以告终。然后，为了明天的重生而认真反省。这么一来，便能获得新生，重新出发。今天的自己，今天就结束，明天将诞生一个全新的自己。<br>     一日就是一生。<br><a id="more"></a></p></blockquote><p>  对于我们普通人来说，今天或许和昨天没有什么不同，每一天都在重复昨天做过的事情，生活对我们大多数人来说就是不断的重复昨天。有时会疲倦，有时也会茫然，但生活还得继续，不会因为你的小情绪，而迁就着你。身边的环境是不会改变的，唯一能改变的就是自己，努力去发现生活中的美，时刻反省自身，不断提醒自己过去的已经过去，每一日都是一个全新的自己，当你用全新的眼光观察世界，会发现每一天，每一个人都不同。五月来了，今天早上去上班意外的发现小区栅栏上的蔷薇开了，黄色的，红色的，粉色的，甚是好看，才发现每天匆匆忙忙的脚步一直往前走，竟然错过了这份美景，错过了一份好心情(<em>^__^</em>) </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 一日就是一生&lt;br&gt;                 —–（日）酒井雄哉&lt;/p&gt;
&lt;p&gt;修行的每天早上，我都穿着草鞋出去。上山10公里之后，接着走10公里较平坦的路，最后是10公里的下坡路，如此这般每天重复。结束一天的登山行程后，草鞋往往变形、穿烂，隔天得穿上新鞋才行。&lt;br&gt;     日复一日地不断重复。有一天，我发现草鞋就像我自己。当脱掉草鞋的那一刻，今天的自己既以告终。然后，为了明天的重生而认真反省。这么一来，便能获得新生，重新出发。今天的自己，今天就结束，明天将诞生一个全新的自己。&lt;br&gt;     一日就是一生。&lt;br&gt;
    
    </summary>
    
      <category term="Thinking" scheme="http://yikeshu.info/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>读《三体》</title>
    <link href="http://yikeshu.info/2017/02/18/%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yikeshu.info/2017/02/18/三体读书笔记/</id>
    <published>2017-02-18T09:56:03.000Z</published>
    <updated>2018-01-17T06:54:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从买了kindle 读的第一本书就是三体，身边好多人都说很好看，由于很好奇想看看它到底有多好看，结果一看就无法自拔，被它深深的吸引。由于平常上班还有别的事情要做，唯一能够支配的时间就是上下班路上了，每天只能在地铁上看一会，一直看了一个多月吧，才把三部看完。这个故事很长，但真的很精彩.</p><a id="more"></a><p>故事从我们现在的生活开始，到发现外星文明的入侵，人类如何应对，再到整个宇宙。仿佛就是我们身边发生的事情，距离我们并不遥远。第一步中出现的三体游戏，必须穿上V装备才能玩，V装具可以模拟游戏场景中的环境，比如在游戏中是很热的天气，你也可以感受到热量，如果很冷你也能感受到很冷，确实是一个很棒的体验，我们现在也有VR技术，只能通过带上眼镜才能看到虚拟场景，还处于初步阶段，没准以后技术成熟，也会开发出三体小说中的V装具，更真实的体验游戏世界。</p><p>书中好多地方的论证都是基于现在的物理基础知识，电磁波，引力波，天体物理知识运用的轻车熟路，不得不佩服作者知识的广度和深度，如果说是什么影响我让我对天文感兴趣的，那一定非《三体》这部作品莫属了。当我们仰望星空，是不是在另一个世界，另一个宇宙中也有生命活动的物体做着同样的事情。我相信有外星人的存在，宇宙这么大，而我们身处的太阳系只是冰山一角，放眼到整个宇宙只是一颗普通的星星，在茫茫宇宙之中一定有一个星球也适合生命生存，可能离我们很遥远，但我们并不孤单。</p><blockquote><p>那你的生活是一种偶然，世界有这么多变幻莫测的因素，你的人生却没什么变故。</p></blockquote><p>这个世界每一天都有那么多变化莫测的因素，如果一个人的一生都没有什么变故，确实是一种偶然</p><blockquote><p>也许，人类和邪恶的关系，就是大洋与漂浮与其上的冰山的关系，它们其实是同一种物质组成的巨大水体，冰山之所以被醒目地认出来，只是由于其形态不同而已，而它实质上只不过是这整个巨大水体中极小的一部分…人类真正的道德自觉是不可能的，就像他们不可能拔着自己的头发离开大地。要做到这一点，只有借助人类之外的力量。</p></blockquote><p>这是故事的主人公叶文洁，对人类彻底失望后，想借助外星文明，三体世界来改造这个让她失望的世界。</p><blockquote><p>这想法让我的后半辈子有一种很矛盾的心态：有时觉得生命珍贵，一切都重如泰山；有时又觉得人是那么渺小，什么都不值一提。反正日子就在这种奇怪的感觉中一天天过去，不知不觉就老了….</p></blockquote><p>人真的很渺小</p><blockquote><p>大部分人的爱情对象也只是存在于自己的想象之中。他们所爱的并不是现实中的他（她），而只是想象中的他（她），现实中的他（她）只是他们创造梦中情人的一个模板，他们迟早会发现梦中情人与模板之间的差异，如果适应这种差异他们就会走到一起，无法适应就分开，就这么简单。你与大多数人的区别在于：你不需要模板。</p></blockquote><p>大部分的爱情只是存在于自己的想象之中，很有道理</p><blockquote><p>文明像一场五千年的狂奔，不断的进步推动着更快的进步，无数的奇迹催生出更大的奇迹，人类似乎拥有了神一般的力量…但最后发现，真正的力量在时间手里，留下脚印比创造世界更难，在这文明的尽头，他们也只能做远古的婴儿时代做过的事情。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从买了kindle 读的第一本书就是三体，身边好多人都说很好看，由于很好奇想看看它到底有多好看，结果一看就无法自拔，被它深深的吸引。由于平常上班还有别的事情要做，唯一能够支配的时间就是上下班路上了，每天只能在地铁上看一会，一直看了一个多月吧，才把三部看完。这个故事很长，但真的很精彩.&lt;/p&gt;
    
    </summary>
    
      <category term="Read" scheme="http://yikeshu.info/categories/Read/"/>
    
    
  </entry>
  
  <entry>
    <title>数据存储 NSUserDefaults</title>
    <link href="http://yikeshu.info/2017/02/18/nsuserdefaults/"/>
    <id>http://yikeshu.info/2017/02/18/nsuserdefaults/</id>
    <published>2017-02-18T09:55:09.000Z</published>
    <updated>2018-01-17T07:19:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>NSUserDefaults对象是用来保存，恢复应用程序相关的偏好设置，配置数据等等。默认系统允许应用程序自定义它的行为去迎合用户的喜好。你可以在程序运行的时候从用户默认的数据库中读取程序的设置。同时NSUserDefaults的缓存避免了在每次读取数据时候都打开用户默认数据库的操作。可以通过调用synchronize方法来使内存中的缓存与用户默认系统进行同步。<br><a id="more"></a></p><h4 id="存数据"><a href="#存数据" class="headerlink" title="存数据"></a>存数据</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取NSUserDefaults 对象</span></span><br><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">      <span class="comment">// 存数据，不需要设置路径，NSUserDefaults 将数据保存在preferrences目录下</span></span><br><span class="line">[userDefaults setObject:<span class="string">@"Jane"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">[userDefaults setObject:<span class="string">@"phone"</span> forKey:<span class="string">@"1892233232"</span>];</span><br><span class="line">    <span class="comment">// 立刻保存同步数据，（如果不写这句话，会在将来某个时间点将数据保存在preference目录下）</span></span><br><span class="line">[userDefaults synchronize];</span><br></pre></td></tr></table></figure><h4 id="取数据"><a href="#取数据" class="headerlink" title="取数据"></a>取数据</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取NSUserDefaults对象</span></span><br><span class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line"><span class="built_in">NSString</span> *userName  = [userDefaults objectForKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *userPhone  = [userDefaults objectForKey:<span class="string">@"phone"</span>];</span><br></pre></td></tr></table></figure><h4 id="判断一个数据是否存储在NSUserDefaults-中"><a href="#判断一个数据是否存储在NSUserDefaults-中" class="headerlink" title="判断一个数据是否存储在NSUserDefaults 中"></a>判断一个数据是否存储在NSUserDefaults 中</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([userDefaults objectForKey:<span class="string">@"Kite"</span>] == <span class="literal">nil</span>) &#123;</span><br><span class="line">    nslog(<span class="string">@"没有存储Kite用户这个数据"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果存储-key-相同，value-不同的数据，后面的数据会把前面的数据替换掉。"><a href="#如果存储-key-相同，value-不同的数据，后面的数据会把前面的数据替换掉。" class="headerlink" title="如果存储 key 相同，value 不同的数据，后面的数据会把前面的数据替换掉。"></a>如果存储 key 相同，value 不同的数据，后面的数据会把前面的数据替换掉。</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//执行完这行代码，文件中存储的数据就是现在的心value</span></span><br><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setObject:<span class="string">@"phone"</span> forKey:<span class="string">@"1877230212"</span>];</span><br><span class="line">[userDefaults synchronize];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NSUserDefaults对象是用来保存，恢复应用程序相关的偏好设置，配置数据等等。默认系统允许应用程序自定义它的行为去迎合用户的喜好。你可以在程序运行的时候从用户默认的数据库中读取程序的设置。同时NSUserDefaults的缓存避免了在每次读取数据时候都打开用户默认数据库的操作。可以通过调用synchronize方法来使内存中的缓存与用户默认系统进行同步。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yikeshu.info/categories/iOS/"/>
    
    
      <category term="OC" scheme="http://yikeshu.info/tags/OC/"/>
    
  </entry>
  
</feed>
