<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CollectionView 拖拽移动 · MissYang</title><meta name="description" content="CollectionView 拖拽移动 - Sunny Yang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yikeshu.info/atom.xml" title="MissYang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon-logo.png" alt="logo"><span>Sunny Yang</span></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/oneMoreTime1357" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/459674901bd7" target="_blank" class="nav-list-link">JANSHU</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">CollectionView 拖拽移动</h1><div class="post-info">Feb 18, 2017</div><div class="post-content"><h4 id="iOS9新特性，collectionView的退拽"><a href="#iOS9新特性，collectionView的退拽" class="headerlink" title="iOS9新特性，collectionView的退拽"></a>iOS9新特性，collectionView的退拽</h4><ul>
<li>创建collectionView，实现代理方法和Datasource，向collectionView 添加长按事件，如下这是我创建collectionView，注册的cell。</li>
</ul>
<pre><code class="objc">- (UICollectionView *)collectionView {
    if(_collectionView == nil) {
        UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init];
        flowLayout.itemSize = CGSizeMake(45, 45);
        flowLayout.minimumLineSpacing = 10;
        flowLayout.minimumInteritemSpacing = 10;
        flowLayout.sectionInset = UIEdgeInsetsMake(15, 15, 15, 15);
        _collectionView = [[UICollectionView alloc] initWithFrame:CGRectMake(0, 0, KScreenWidth, KScreenHeight) collectionViewLayout:flowLayout];
        _collectionView.delegate = self;
        _collectionView.dataSource = self;
        _collectionView.backgroundColor = [UIColor whiteColor];
        [_collectionView registerClass:[MoveCollectionViewCell class] forCellWithReuseIdentifier:identity];

        UILongPressGestureRecognizer *longPressGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressAction:)];
        [_collectionView addGestureRecognizer:longPressGesture];

    }
    return _collectionView;
}
</code></pre>
<a id="more"></a>
<ul>
<li>实现datasource ，加入数据源，</li>
</ul>
<pre><code class="objc">- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section {
    return _data.count;
}

- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath {
    MoveCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:identity forIndexPath:indexPath];
    cell.img = _data[indexPath.row];
    return cell;
}
</code></pre>
<ul>
<li><p>下面使用iOS9的新特性实现拖拽，必须实现下面的方法</p>
</li>
<li><p>开始移动的时候调用此方法，可以获取相应的datasource方法设置特殊的indexpath 能否移动,如果能移动返回的是YES ,不能移动返回的是NO</p>
</li>
</ul>
<pre><code class="objc">- (BOOL)beginInteractiveMovementForItemAtIndexPath:(NSIndexPath *)indexPath
</code></pre>
<ul>
<li>更新移动过程的位置</li>
</ul>
<pre><code class="objc">- (void)updateInteractiveMovementTargetPosition:(CGPoint)targetPosition
</code></pre>
<ul>
<li>结束移动的时候调用此方法，collectionView 会响应相应的datasource方法，collectionView:moveItemAtIndexPath:toIndexPath:  我们可以在这个方法中将移动的数据源，与目标数据源交互位置。</li>
</ul>
<pre><code class="objc">- (void)endInteractiveMovement
</code></pre>
<ul>
<li>取消移动的时候调用，会返回最原始的位置。</li>
</ul>
<pre><code class="objc">- (void)cancelInteractiveMovement;
</code></pre>
<ul>
<li>在开始移动的时候会调用这个方法，如果有特殊的单元格不想被移动可以return NO， 如果没有限制就返回YES 吧。</li>
</ul>
<pre><code class="objc">- (BOOL)collectionView:(UICollectionView *)collectionView canMoveItemAtIndexPath:(NSIndexPath *)indexPath
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明            </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">collectionView</td>
<td style="text-align:left">调用这个代理方法的 collection View</td>
</tr>
<tr>
<td style="text-align:left">indexPath</td>
<td style="text-align:left">collectionView 中想要移动的 indexpath</td>
</tr>
</tbody>
</table>
<ul>
<li>移动结束的时候会调用此datasource，想要拖拽完成之后数据正确必须实现此方法，使用新的路径更新数据源，如果不实现此方法，刚刚移动cell中的数据不会重新排列。</li>
</ul>
<pre><code class="objc">- (void)collectionView:(UICollectionView *)collectionView moveItemAtIndexPath:(NSIndexPath *)sourceIndexPath
           toIndexPath:(NSIndexPath *)destinationIndexPath
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">说明            </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">collectionView</td>
<td style="text-align:left">正在响应这个方法的collectionView</td>
</tr>
<tr>
<td style="text-align:left">sourceIndexPath</td>
<td style="text-align:left">原始移动的indexpath</td>
</tr>
<tr>
<td style="text-align:left">destinationIndexPath</td>
<td style="text-align:left">移动到目标位置的indexpath</td>
</tr>
</tbody>
</table>
<ul>
<li>刚刚我们已经给collectionView 添加了长按的手势，目的就是长按的时候，可以拖动cell来进行移动，那怎么开始移动呢？我们来实现长按事件看看。</li>
</ul>
<pre><code class="objc">- (void)longPressAction:(UILongPressGestureRecognizer *)longPress {
    //获取此次点击的坐标，根据坐标获取cell对应的indexPath
    CGPoint point = [longPress locationInView:_collectionView];
    NSIndexPath *indexPath = [self.collectionView indexPathForItemAtPoint:point];
    //根据长按手势的状态进行处理。
    switch (longPress.state) {
        case UIGestureRecognizerStateBegan:
            //当没有点击到cell的时候不进行处理
            if (!indexPath) {
                break;
            }
            //开始移动
            [_collectionView beginInteractiveMovementForItemAtIndexPath:indexPath];
            break;
        case UIGestureRecognizerStateChanged:
        //移动过程中更新位置坐标
            [_collectionView updateInteractiveMovementTargetPosition:point];
            break;
        case UIGestureRecognizerStateEnded:
        //停止移动调用此方法
            [_collectionView endInteractiveMovement];
            break;
        default:
        //取消移动
            [_collectionView cancelInteractiveMovement];
            break;
    }
}
</code></pre>
<ul>
<li>下面这两个方法都需要实现。<br>```objc<br>// 在开始移动时会调用此代理方法，</li>
<li>(BOOL)collectionView:(UICollectionView <em>)collectionView canMoveItemAtIndexPath:(NSIndexPath </em>)indexPath {<pre><code>  //根据indexpath判断单元格是否可以移动，如果都可以移动，直接就返回YES ,不能移动的返回NO
  return YES;
</code></pre>}    </li>
</ul>
<p>// 在移动结束的时候调用此代理方法</p>
<ul>
<li><p>(void)collectionView:(UICollectionView <em>)collectionView moveItemAtIndexPath:(NSIndexPath </em>)sourceIndexPath toIndexPath:(NSIndexPath<em>)destinationIndexPath {<br>  /**
   </em>sourceIndexPath 原始数据 indexpath</p>
<ul>
<li><p>destinationIndexPath 移动到目标数据的 indexPath<br>*/</p>
<p>[_data removeObjectAtIndex:sourceIndexPath.row];<br>UIImage *img = _data[sourceIndexPath.row]<br>[_data insertObject:img atIndex:destinationIndexPath.row];<br>}<br>```</p>
</li>
</ul>
</li>
</ul>
<h4 id="自己写collectionView拖拽的方法"><a href="#自己写collectionView拖拽的方法" class="headerlink" title="自己写collectionView拖拽的方法"></a>自己写collectionView拖拽的方法</h4><ul>
<li><p>如果你的手机支持iOS9或更高版本，使用苹果为我们提供的方法实现拖拽功能是没有问题的。相信还有很多都在支持ios8，所以下面的方法也许很适用。</p>
<ul>
<li><p>在<strong>- (UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</strong> 方法中，为每个cell添加长按手势，这样就可以在你长按cell的时候响应事件。</p>
</li>
<li><p>下面我们看看长按事件中应该实现怎样的方法。</p>
</li>
</ul>
</li>
</ul>
<pre><code class="objc">- (void)longPressAction:(UILongPressGestureRecognizer *)longPress {
       //获取当前cell所对应的indexpath 
       MoveCollectionViewCell *cell = (MoveCollectionViewCell *)longPress.view;
    NSIndexPath *cellIndexpath = [_collectionView indexPathForCell:cell];

    //将此cell 移动到视图的前面
    [_collectionView bringSubviewToFront:cell];
    _isChange = NO;

    switch (longPress.state) {
        case UIGestureRecognizerStateBegan: {
        //使用数组将collectionView每个cell的 UICollectionViewLayoutAttributes 存储起来。
            [self.cellAttributesArray removeAllObjects];
            for (int i = 0; i &lt; self.data.count; i++) {
                [self.cellAttributesArray addObject:[_collectionView layoutAttributesForItemAtIndexPath:[NSIndexPath indexPathForRow:i inSection:0]]];
            }
        }
            break;
        case UIGestureRecognizerStateChanged: {
            //在移动过程中，使cell的中心与移动的位置相同。
            cell.center = [longPress locationInView:_collectionView];
            for (UICollectionViewLayoutAttributes *attributes in self.cellAttributesArray) {
            //判断移动cell的indexpath，是否和目的位置相同，如果相同isChange为YES,然后将数据源交换
                if (CGRectContainsPoint(attributes.frame, cell.center) &amp;&amp; cellIndexpath != attributes.indexPath) {
                    _isChange = YES;
                    NSString *imgStr = self.data[cellIndexpath.row];
                    [self.data removeObjectAtIndex:cellIndexpath.row];
                    [self.data insertObject:imgStr atIndex:attributes.indexPath.row];
                    [self.collectionView moveItemAtIndexPath:cellIndexpath toIndexPath:attributes.indexPath];
                }
            }

        }
            break;
        case UIGestureRecognizerStateEnded: {
            //如果没有改变，直接返回原始位置
            if (!_isChange) {
                cell.center = [_collectionView layoutAttributesForItemAtIndexPath:cellIndexpath].center;
            }
        }
            break;
        default:
            break;
    }
}
</code></pre>
<p> 不使用iOS9的代理方法，实现拖拽移动也很简单,可以试试。<br> 代码已经放到github仓库请点击这里 <strong><a href="https://github.com/oneMoreTime1357/CollectionViewTips" target="_blank" rel="noopener">项目链接</a></strong> 查看</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/02/18/nsuserdefaults/" class="prev">PREV</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'http-yikeshu-info';
var disqus_identifier = '2017/02/18/CollectionView_dragMove/';
var disqus_title = 'CollectionView 拖拽移动';
var disqus_url = 'http://yikeshu.info/2017/02/18/CollectionView_dragMove/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//http-yikeshu-info.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2018 <a href="http://yikeshu.info">Sunny Yang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/oneMoreTime1357/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>