<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 理解JavaScript中的闭包 · MissYang</title><meta name="description" content="理解JavaScript中的闭包 - 杨小丹"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yikeshu.info/atom.xml" title="MissYang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon-logo.png" alt="logo"><span>杨小丹</span></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/oneMoreTime1357" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/459674901bd7" target="_blank" class="nav-list-link">JANSHU</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">理解JavaScript中的闭包</h1><div class="post-info">Aug 11, 2017</div><div class="post-content"><p>闭包并不复杂。学习和理解闭包的基础知识仅仅只需要10分钟。</p>
<h4 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h4><p>闭包是JavaScript的一部分，每个工程师都应该知道和理解闭包。今天的文章只是撇开闭包的表面，但是将会给你一个很好的思想，关于什么是闭包和它在JavaScript中是如何运行的。好了，接下来我们开始吧。</p>
<p>我们先从书本中闭包的定义开始。<br><a id="more"></a></p>
<h4 id="定义1"><a href="#定义1" class="headerlink" title="定义1"></a>定义1</h4><blockquote>
<p>闭包是一个能访问父作用域的函数，即使此作用域关闭了。</p>
</blockquote>
<h4 id="定义2"><a href="#定义2" class="headerlink" title="定义2"></a>定义2</h4><blockquote>
<p>闭包是一个函数和该函数被声明的词汇环境的组合。</p>
</blockquote>
<p>很好，但是这些真正的意思是什么？</p>
<p>首先你需要理解在JavaScript中的<strong>作用域</strong>，作用域实质上是变量在JavaScript中的生命周期。因此，当一个变量定义了一个大的作用域，这个变量会存活多久，那个方法在你的程序中会访问到它。</p>
<p>让我们看一个例子。</p>
<p>当你在JavaScript中创建一个函数，它可以访问创建在这个函数里面和外面的变量。</p>
<p>变量创建在一个函数中也定义了这个变量。一个局部变量只能在这个被定义的函数里面访问到。在下面这个例子中，你将会看到如果我们尝试在这个函数外面打印<code>words</code>，它会输出错误信息。这是因为<code>words</code>是一个内部作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak () &#123;</span><br><span class="line">  var words = &apos;hi&apos;;</span><br><span class="line">  console.log(words);</span><br><span class="line">&#125;</span><br><span class="line">speak(); // hi</span><br><span class="line">console.log(words); // undefined</span><br></pre></td></tr></table></figure>
<p>和上一个例子不同，这次我们定义这个words 为全局作用域。<br>意思是说我们可以在任何函数中访问这个变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 将变量放到函数的外面</span><br><span class="line">// words 现在是个全局变量</span><br><span class="line">var words = &apos;hi&apos;;</span><br><span class="line">function speak()&#123; </span><br><span class="line">  console.log(words);</span><br><span class="line">&#125;</span><br><span class="line">speak(); // &apos;hi&apos; </span><br><span class="line">console.log(words); // &apos;hi&apos;</span><br></pre></td></tr></table></figure>
<h4 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h4><p>我们将一个函数放到另一个函数里面会发生什么？我想你跟着操作下面的例子，因为这个会很有趣！</p>
<p>如果你使用谷歌浏览器，打开你的开发工具调试模式：<br>[Windows]：Ctrl + Shift + J<br>[MAC]：Cmd + Opt + J</p>
<p>Cool，现在拷贝下面的代码然后粘贴到你的控制台中。我们现在做的是创建一个名字为<code>speak</code>的函数。<code>speak</code>返回一个名称为<code>logIt</code>的函数。最终<code>logIt</code>在控制台中打印log值为<code>words</code>，在这个实例要实现在控制台中输出 <code>‘hi’</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">  return function logIt() &#123;</span><br><span class="line">    var words = &apos;hi&apos;;</span><br><span class="line">    console.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当你拷贝到这段代码到你的控制台中，我们将要创建一个变量，然后将speak函数赋值给它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sayHello = speak();</span><br></pre></td></tr></table></figure></p>
<p>现在我们可以看见这个变量<code>sayHello</code> 调用了之后，没有执行内部函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sayHello;</span><br><span class="line">//  function logIt() &#123;</span><br><span class="line">//    var words = &apos;hi&apos;;</span><br><span class="line">//    console.log(words);</span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure></p>
<p>如上打印的结果，<code>sayHello</code> 打印的是我们return的内部函数，也就是说，如果我们执行<code>sayHello()</code>在控制台中，它将会唤起执行<code>logIt()</code>函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sayHello();</span><br><span class="line">// &apos;hi&apos;</span><br></pre></td></tr></table></figure></p>
<p>它奏效了，但是并没有任何特别。让我们移除一行代码看看什么发生了改变。请看下面的示例。我们将清楚定义的变量<code>words</code>移到<code>speak()</code>函数的里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">  var words = &apos;hi&apos;;</span><br><span class="line">  return function logIt() &#123;</span><br><span class="line">    console.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>像之前的操作，让我们定义一个变量并将speak函数赋值给它:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sayHello = speak();</span><br></pre></td></tr></table></figure></p>
<p>现在我们看看我们的 sayHello变量会输出什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHello</span><br><span class="line">//  function logIt() &#123;</span><br><span class="line">//    console.log(words);</span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure></p>
<p>哦，这里没有<code>words</code> 变量的定义，那么发生了什么当我们执行这个函数的时候？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sayHello();</span><br><span class="line">// &apos;hi&apos;</span><br></pre></td></tr></table></figure></p>
<p>它仍然起作用了！这是因为你刚刚体验了闭包的影响。</p>
<p>是否有点疑惑？没关系，回想下我们的闭包的定义：</p>
<blockquote>
<p>闭包是一个能访问父作用域的函数，即使此作用域关闭了。</p>
</blockquote>
<p>在这个例子中我们的<code>speak()</code>函数作用域关闭了。这意味着 <code>var words = &#39;hi&#39;</code> 应该消失了。然而，在JS中我们有一个名称将这种现象叫做闭包：<strong><em>我们的内部函数保持对其创建的范围的引用</em></strong>。这就允许<code>logIt()</code>函数仍然可以访问<code>words</code>这个变量——即使<code>speak()</code>这个函数作用域关闭了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function speak() &#123;</span><br><span class="line">  var words = &apos;hi&apos;;</span><br><span class="line">  return function logIt() &#123;</span><br><span class="line">    console.log(words);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>重要提示，在JavaScript中每个函数都有一个闭包。你不需要你去解释闭包在函数中是怎么运行的，它仅仅只是JavaScript的一部分。</p>
</blockquote>
<h2 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h2><p>让我们查看另一个例子。这个例子有点复杂，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function name(n) &#123;</span><br><span class="line">  return function(a) &#123;</span><br><span class="line">    return `$&#123;n&#125; likes $&#123;a&#125;`;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们定义了一个名字为<code>name</code> 的函数可以传递一个参数，返回一个匿名函数，可以传递一个不同的参数，内部函数返回一个字符串。</p>
<p>我们用<code>name</code>函数创建两个变量。一个我们给name函数传递 John，另一个传 Cindy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var j = name(&apos;John&apos;);</span><br><span class="line">var c = name(&apos;Cindy&apos;);</span><br></pre></td></tr></table></figure></p>
<p>让我们看看<code>j</code>现在能打印什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j;</span><br><span class="line">//  function (a) &#123;</span><br><span class="line">//    return `$&#123;n&#125; likes $&#123;a&#125;`;</span><br><span class="line">//  &#125;</span><br></pre></td></tr></table></figure></p>
<p>所以根据之前示例我们知道这是因为闭包，这个函数应该仍然可以访问<code>n</code>的变量通过父作用域。我们所能做的是把<code>a</code>传递过去，在执行函数的时候。</p>
<p>让我们试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j(&apos;dogs&apos;);  // &apos;John likes dogs&apos;</span><br><span class="line">c(&apos;cats&apos;);  // &apos;Cindy likes cats&apos;</span><br></pre></td></tr></table></figure></p>
<p>成功了！因为闭包我们才能从之前关闭的作用域引用变量成功的执行我们的函数。</p>
<hr>
<p>##总结<br>希望你现在可以理解基本的闭包在JavaScript和它是如何运行的！这虽然只是冰山一角，但明白了基础知识才能学习和练习更复杂的闭包。</p>
<hr>
<p>翻译原文链接：<a href="https://codeburst.io/understand-closures-in-javascript-d07852fa51e7" target="_blank" rel="noopener">https://codeburst.io/understand-closures-in-javascript-d07852fa51e7</a><br>翻译中有疏漏的地方，欢迎指正。</p>
<p>校对：蹦蹦</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/01/17/start2018/" class="prev">PREV</a><a href="/2017/08/11/解决Chrome不能播放mp4视频的问题和HLS视频播放/" class="next">NEXT</a></div><div data-thread-key="2017/08/11/[译]理解JavaScript中的闭包/" data-title="理解JavaScript中的闭包" data-url="http://yikeshu.info/2017/08/11/[译]理解JavaScript中的闭包/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"6280987357357278000"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2017 - 2018 <a href="http://yikeshu.info">杨小丹</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/oneMoreTime1357/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>